<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: puppet | Shit Gary Says]]></title>
  <link href="http://garylarizza.com/blog/categories/puppet/atom.xml" rel="self"/>
  <link href="http://garylarizza.com/"/>
  <updated>2014-10-24T14:19:53+02:00</updated>
  <id>http://garylarizza.com/</id>
  <author>
    <name><![CDATA[Gary larizza]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Puppet Workflows 4: Using Hiera in anger]]></title>
    <link href="http://garylarizza.com/blog/2014/10/24/puppet-workflows-4-using-hiera-in-anger/"/>
    <updated>2014-10-24T15:13:49+02:00</updated>
    <id>http://garylarizza.com/blog/2014/10/24/puppet-workflows-4-using-hiera-in-anger</id>
    <content type="html"><![CDATA[<p>Hiera. That thing nobody is REALLY quite sure how to say (FYI: It&rsquo;s pronounced
&lsquo;hiera&rsquo;), the tool that everyone says you should be using, and the tool that
will make you hate YAML syntax errors with a passion. It&rsquo;s a data/code
separation dream, (potentially) a debugging nightmare, and absolutely vital in
creating a Puppet workflow that scales better than your company&rsquo;s Wifi strategy
(FYI: your company&rsquo;s Wifi password just changed. Again. Because they&rsquo;re not
using certificates). I&rsquo;ve already written a GOOD AMOUNT on why/how to use it,
but now I&rsquo;m going to give you a couple of edge cases. Call them &ldquo;best
practices&rdquo; (and I&rsquo;ll cut you), but I like to call it &ldquo;shit I learned
after using Hiera in anger.&rdquo; Here are a couple of the most popular questions
I hear, and my usual responses&hellip;</p>

<h2>&ldquo;How should I setup my hierarchy?&rdquo;</h2>

<p>This is such a subjective question because it&rsquo;s specific to your organization
(because it&rsquo;s your data). I usually ask back &ldquo;What are the things about your
nodes that are different, and when are they different?&rdquo; Usually I hear something
back like &ldquo;Well, nodes in this datacenter have different DNS settings&rdquo; or
&ldquo;Application servers in production use one version of java, and those in dev
use a different version&rdquo; or &ldquo;All machines in the dev environment in this datacenter
need to have a specific repository&rdquo;. All of these replies give me ideas to your
hierarchy.  When you think of Hiera as a giant conditional statment, you can
start seeing how your hierarchy could be laid out.  With the first response, we
know we need a <code>location</code> fact to determine where a node is, and then we can
have a hierarchy level for that location. The second response tells me we need
a level for the application tier (i.e. dev/test/prod).  The third response tells
me we need a level that combines both the location and the application tier. When
you add in that you should probably have a node-specific level at the top (for
overrides) and a default level at the bottom (or not: see the next section), I&rsquo;m
starting to picture this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">:hierarchy</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; &amp;ldquo;nodes/%{::clientcert}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;%{::location}/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;%{::location}/common&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;tier/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; common</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Every time you have a need, you consider a level.  Now, obviously, it doesn&rsquo;t
mean that you NEED a level for every request (sometimes if it&rsquo;s an edge case
you can handle it in the profile or the role). There&rsquo;s a performance hit for
every level of your Hiera hierarchy, so ideally keep it minimal (or around
5 levels or so), but we&rsquo;re talking about flexibility here, and, if that&rsquo;s more
important than performance then you should go for it.</p>

<p>Next comes ordering. This one&rsquo;s SLIGHTLY easier &ndash; your hierarchy should read from
most-specific to least-specific. Note that when you specify an application tier
at a specific location that that it is MORE specific than just saying &ldquo;all nodes in
this application tier.&rdquo; Sometimes you will have levels that might be hard to
define an order &ndash; such as location vs. application tier. You kinda just have to
go with your gut here. In many cases you may find that the data you put in those
two levels will be entirely different (location-based data may not ever overlap
with application-tier-specific data). Do remember than any time you change the
order of your hierarchy you&rsquo;re going to introduce the possibility that values
get flip/flopped.</p>

<p>If you look at level 3 of the hierarchy above, you&rsquo;ll see that I have &lsquo;common&rsquo;
at the end. Some people like this syntax (where they put a &lsquo;common&rsquo; file in a
folder that matches the fact they&rsquo;re checking against), and some people prefer
a filename matching the fact.  Do what makes you happy, but, in this case,
we can unify the location folder and just put the common file underneath the
application tier files.</p>

<p>Finally, DO MAKE USE OF FOLDERS!  For the love of god, this. Putting all files
in a single folder both makes that a BIG folder, but also introduces a namespace
collision (i.e. what if you have a location named &lsquo;dev&rsquo; for example? Now you have
both an application tier and a location with the same name.  Oops).</p>

<p>How you setup your hierarchy is up to you, but this should hopefully give you
somewhere to start.</p>

<h2>An argument AGAINST {global,common}.yaml</h2>

<p>I might as well drum up some controversy now&hellip;</p>

<p>When using Hiera, you need to define a hierarchy that Hiera uses in its search
for your data. Most often, it looks something like this:</p>

<h2><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>hiera.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">&lt;/h2&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;p&gt;:backends</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; yaml</span>
</span><span class='line'><span class="l-Scalar-Plain">:yaml</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">:datadir</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/etc/puppetlabs/puppet/hieradata</span>
</span><span class='line'><span class="l-Scalar-Plain">:hierarchy</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; &amp;ldquo;nodes/%{::clientcert}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;location/%{::location}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;environment/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; common</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Notice that little &ldquo;common&rdquo; at the end?  That means that, failing everything
else, it&rsquo;s going to look in <code>common.yaml</code> for a value.  This means that
<code>common.yaml</code> is a storage bin of default values.</p>

<p>Previously, you may have heard me rail against Hiera&rsquo;s optional second argument
and how I really don&rsquo;t like it.  Take this example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$foo</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">port</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">,</span> <span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="m">80</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Given this code, Hiera is going to look for a parameter called &lsquo;port&rsquo; in its
hierarchy, and, if it doesn&rsquo;t find one in ANY of the levels, assign back a default
value of &lsquo;80&rsquo;.  I don&rsquo;t like using this second argument because:</p>

<ol>
<li>If you forget to enter the &lsquo;port&rsquo; parameter into the hierarchy, or typo it in the YAML file, Hiera will gladly assign the default value of &lsquo;80&rsquo; (which, unless you&rsquo;re checking for this, might sneak and get into production)</li>
<li>Where is the real &lsquo;default&rsquo; value: the value in <code>common.yaml</code> or the optional second argument?</li>
</ol>


<p>Okay, so we&rsquo;re resigned to never use the second argument.  Cool.  BUT, what
happens when you already have a value in <code>common.yaml</code> and you typo the name
of the parameter at a higher level (for example, you write &ldquo;prot: 44&rdquo; inside
a YAML file at a higher level)?  You&rsquo;re going to get the value in <code>common.yaml</code>,
and, again, unless you&rsquo;re watching for this, suddenly you get a default value
when you didn&rsquo;t expect it.</p>

<p>So, what is this value in <code>common.yaml</code> used for anyways? Well, it&rsquo;s a value
default for every node that needs it.  And where are we going to be getting
this value?  If you said &ldquo;The Profile&rdquo;, you would be correct.  So what should
we do about this?  I say you hardcode the value right into the Profile (GASP!!)
I will talk about this more in the next section (because it&rsquo;s more appropriate
there), so just hold that thought for another section.</p>

<p>Until then, let me say that I&rsquo;ve started to align myself with the idea that
<code>hiera.yaml</code> shouldn&rsquo;t have a &ldquo;defaults&rdquo; level.  The idea is that if there&rsquo;s
a value that every node should have, keep it visible and in the Profile. If
you need Hiera&rsquo;s dynamic lookup capability, THEN drop it into the hierarchy.
The downside of this philosophy is that you&rsquo;ll suddenly need to enter a value
in many different places (i.e. if suddenly you want to define a different port
in the &lsquo;dev&rsquo; application tier than in all the other application tiers, then you
need to add the port parameter to EVERY ONE of your application tier files. If
you have 8 of these tiers, then you need to enter the value into all 8 files).
This is also less-than-ideal, but what are you optimizing for here?  You&rsquo;re
optimizing for early failure.  If Hiera can&rsquo;t find a value and it SHOULD, this
is an early failure at catalog compilation time. You&rsquo;ll know INSTANTLY that
there&rsquo;s a problem (instead of deploying a default value to production, for
example).</p>

<p>If you don&rsquo;t need this level of optimization, by all means keep the default
level.  If you don&rsquo;t want this much redundancy by entering values in multiple
files, by all means keep the default level.  I simply offer forth a solution
for those folks who are wanting a &ldquo;fail-early, fail-often&rdquo; approach in their
data lookup mechanism.</p>

<p><strong>NOTE</strong>: You&rsquo;re never going to completely escape the idea of typos. Even
if you remove the &ldquo;defaults&rdquo; level in the hierarchy, you could still have the
case where you enter a port value in every file at the <code>$::applicationtier</code>
level, but maybe typo the parameter at a higher level.  In this case, Hiera
DOES return a value, but it&rsquo;s the <code>$::applicationtier</code> value.  This requires
&ldquo;CONSTANT VIGILANCE!&rdquo; to catch these cases, but the idea is that these edge
cases are much less than a defaults-level override, so you SHOULD be able to
spot it easier. No level of automation will totally remove human error (and
watch The Matrix if you don&rsquo;t believe me).</p>

<h2>Where to data &ndash; Hiera or Profile?</h2>

<p>&ldquo;Does this go right into the Profile or into Hiera?&rdquo;  I get that question
repeatedly when I&rsquo;m working with customers. It&rsquo;s a good question, and one of
the quickest ways to blow up your YAML files in Hiera. Here&rsquo;s the order I use
when deciding where to put data:</p>

<h3>Enter the data into the Profile itself</h3>

<p>Yes, that&rsquo;s exactly what I said &ndash; put it in the Profile.  &ldquo;BUT GARY!&rdquo;, you
should be thinking, &ldquo;THAT&rsquo;S EMBEDDING DATA INSIDE YOUR PUPPET CODE!&rdquo;  To that
I say: &ldquo;It depends on how you look at the problem and solution.&rdquo; The profile is
YOUR implementation.  It describes how YOU define the implementation of a piece
of technology in YOUR organization. As such, it&rsquo;s less about Puppet code and
more about pulling data and passing it TO the Puppet code. It&rsquo;s the glue-code
that grabs the data and wires it up to the model that uses it. How it grabs the
data is not really a big deal, so long as it grabs the RIGHT data &ndash; right? You
can choose to hardcode it into the Profile, or use Hiera, or use some other
magical data lookup mechanism &ndash; we don&rsquo;t really care (so long as the Profile
gathers the data and passes it to the correct Puppet class).</p>

<p>&ldquo;BUT GARY! IT&rsquo;S GOING TO MAKE IT HARD TO DEBUG!&rdquo;  Not really. You&rsquo;re going to
have to open the Profile anyway to see what&rsquo;s going on (whether you pull the
data from Hiera or hardcode it in the Profile), right? And, arguably, the
Profile is legible&hellip;doing Hiera lookups gives you flexibility at a cost of
abstracting away how it got that bit of data (i.e. &ldquo;It used Hiera&rdquo;). For newer
users of Puppet, having the data in the Profile is easier to follow. So, in the
end, putting the data into the Profile itself is the least-flexible and most-visible
option&hellip;so consequently it should be the first available option. This option
is best for defaults that are applicable for ALL nodes.</p>

<p>Remember when I offered that crazy idea of not having a &ldquo;defaults&rdquo; level in the
hierarchy?  This is why: erring on the side of visibility in the Profile and
failing early with Hiera. It also gives you a logical starting point when
determining WHERE to put your data.  Moving along&hellip;</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Data is clearly visible and legible in the profile (no need to open additional files)</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Inability to redefine variables in Puppet DSL makes any settings constants by default (i.e. no overriding permitted)</li>
</ul>


<h3>Enter the data into Hiera</h3>

<p>If you find that you need to have different bits of data for different nodes
(i.e. a different version of Java in the dev tier instead of the prod tier),
then you can start to put the data into Hiera.</p>

<p><strong>NOTE</strong>: If you subscribe to my &ldquo;no defaults&rdquo; philosophy above, you suddenly
need to enter the data into as many files as that level of the hierarchy has
(or more if you override at a higher level). Understand that you&rsquo;re not me,
and you DON&rsquo;T NEED to subscribe to this &ldquo;no defaults&rdquo; view of the world. Yay
for being different!</p>

<p>Where to put the data is going to depend on your own needs &ndash; I&rsquo;m trusting that
you can figure this part out :)</p>

<p>This answers that &ldquo;where&rdquo; question, but doesn&rsquo;t answer the &ldquo;what&rdquo; question&hellip;as
in &ldquo;What data should I put into Hiera?&rdquo;  For that, we have another section&hellip;</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Flexibility in returning different values based on different conditions</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Visibility &ndash; you must do a Hiera lookup to find the value (or open Hiera&rsquo;s YAML files)</li>
</ul>


<h2>&ldquo;What exactly goes into Hiera?&rdquo;</h2>

<p>If there were one question that, if answered incorrectly, could make or break
your Puppet deployment, this would be it. The greatest strength and weakness of
Hiera is its flexibility.  You can truly put almost anything in Hiera, and, when
combined with something like the create_resources() function, you can create
your own YAML configuration language (tip: don&rsquo;t actually do this).</p>

<p>&ldquo;But, seriously, what should go into Hiera, and what shouldn&rsquo;t?&rdquo;</p>

<p>The important thing to consider here is the price you pay by putting data into
Hiera. You&rsquo;re gaining flexibility at a cost of visibility.  This means that you
can do things like enter values at all level of the hierarchy that can be
concatenated together with a single hiera_array() call, BUT, you&rsquo;re losing the
visibility of having the data right in front of you (i.e. you need to open up
all the YAML files individually, or use the <code>hiera</code> binary to debug how you got
those values). Hiera is REALLY COOL until you have to debug why it grabbed (or
DIDN&rsquo;T grab) a particular value.</p>

<p>Here&rsquo;s what I usually tell people about what should be put into Hiera:</p>

<ul>
<li>The exact data values that need to be different conditionally (i.e. a different ntp server for different sites, different java versions in dev/prod, a password hash, etc.)</li>
<li>Dynamic data expressed in multiple levels of the hierarchy (i.e. a lookup for &lsquo;packages&rsquo; that returns back an array of all the values that were found in all the levels of the hierarchy)</li>
<li>Resources as a hash ONLY WHEN ABSOLUTELY NECESSARY</li>
</ul>


<h3>Puppet manifest vs. create_resources()</h3>

<p>Bullets 1 and 2 above should be pretty straightforward &ndash; you either need to use
Hiera to grab a specific value or return back a list of ALL the values from ALL
the levels of the hierarchy. The point here is that Hiera should be returning
back only the minimal amount of data that is necessary (i.e. instead of
returning back a hash that contains the title of the resource, all the attributes
of the resource, and all the attribute values for that resource, just return
back a specific value that will be assigned to an attribute&hellip;like the password
hash itself for a user). This data lookup appears to be &ldquo;magic&rdquo; to new users of
Puppet &ndash; all they see is the magic phrase of &ldquo;hiera&rdquo; and a parameter to search
for &ndash; and so it becomes slightly confusing. It IS, however, easier to understand
that this magical phrase will return data, and that that data is going to be used
to set the value for an attribute. Consider this example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$password</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">garypassword</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span><span class="o">&lt;</span><span class="err">/</span><span class="ss">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="ss">p</span><span class="o">&gt;</span><span class="ss">user</span> <span class="err">{</span> <span class="err">&amp;lsquo;gary&amp;rsquo;:</span>
</span><span class='line'>  <span class="err">ensure</span>   <span class="err">=&gt;</span> <span class="err">present,</span>
</span><span class='line'>  <span class="err">uid</span>      <span class="err">=&gt;</span> <span class="err">&amp;lsquo;5001&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">gid</span>      <span class="err">=&gt;</span> <span class="err">&amp;lsquo;gary&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">shell</span>    <span class="err">=&gt;</span> <span class="err">&amp;lsquo;zsh&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">password</span> <span class="err">=&gt;</span> <span class="nv">$password</span><span class="err">,</span>
</span><span class='line'><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This leads us to bullet 3, which is &ldquo;the Hiera + create_resources() solution.&rdquo;
This solution allows you to lookup data from within Hiera and pass it directly
to a function where Puppet creates the individual resources as if you had typed
them into a Puppet manifest itself. The previous example can be entered into
a Hiera YAML file like so:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>sysadmins.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">users</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">gary:&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;pre&gt;&lt;code&gt;ensure</span><span class="p-Indicator">:</span> <span class="s">&#39;present&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">uid</span><span class="p-Indicator">:</span> <span class="s">&#39;5001&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">gid</span><span class="p-Indicator">:</span> <span class="s">&#39;gary&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">shell</span><span class="p-Indicator">:</span> <span class="s">&#39;zsh&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">password</span><span class="p-Indicator">:</span> <span class="s">&#39;biglongpasswordhash&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And then a resource can be created inside the Puppet DSL by doing the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$users</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">users</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span><span class='line'><span class="nf">create_resources</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">users</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Both examples are functionally identical, except the first one only uses Hiera
to get the password hash value, whereas the second one grabs both the
attributes, and their values, for a specific resource. Imagine Puppet gives you
an error with the &lsquo;gary&rsquo; user resource and you were using the latter example.
You grep your Puppet code looking for &lsquo;gary&rsquo;, but you won&rsquo;t find that user
resource in your Puppet manifest anywhere (because it&rsquo;s being created with the create_resources() function).
You will instead have to know to go into Hiera&rsquo;s data directory, then the
correct datafile, and then look for the hash of values for the &lsquo;gary&rsquo; user.</p>

<h3>Functional differences between the two approaches</h3>

<p>Functionally, you COULD do this either way. When you come up with a solution
using create_resources(), I challenge you to draw up another solution using
Puppet code in a Puppet manifest (however lengthy it may be) that queries Hiera
for ONLY the specific values necessary. Consider this example, but, instead,
you need to manage 500 users.
If you use create_resources(), you would then need to add 500 more blocks to
the &lsquo;users&rsquo; parameter in your Hiera datafiles.  That&rsquo;s a lot of YAML. And on
what level will you add these blocks? <code>prod.yaml</code>? <code>dev.yaml</code>? Are you using a
<code>common.yaml</code>? Your YAML files suddenly got huge, and the rest of your team
modifying them will not be so happy to scroll through 500 entries. Now consider
the first example using Puppet code. Your Puppet manifest suddenly grew, but it
didn&rsquo;t affect all the OTHER manifests out there: only this file. The Hiera YAML
files will still grow &ndash; but now 500 individual lines instead of 3000 lines in
the previous example. Okay, now which one is more LEGIBLE? I would argue that
the Puppet manifest is more legible, because I consider the Puppet DSL to be
very legible (again, subject to debate versus YAML). Moreover, when debugging,
you can stay inside Puppet files more often using Puppet manifests to define
your resources. Using create_resources, you need to jump into Hiera more often.
That&rsquo;s a context shift, which adds more annoyance to debugging. Also, it
creates multiple &ldquo;sources of truth.&rdquo; Suddenly you have the ability of entering
data in Hiera as well as entering it in the Puppet manifest, which may be clear
to YOU, but if you leave the company, or you get another person on your team,
they may choose to abuse the Hiera settings without knowing why.</p>

<p>Now consider an example that you might say is more tailored to create_resources().
Say you have a defined type that sets up tomcat applications. This defined type
accepts things like a path to install the application, the application&rsquo;s package
name, the version, which tomcat installation to target, and etc. Now consider
that all application servers need application1, but only a couple
of servers need application2, and a very snowflake server needs application3 (in
this case, we&rsquo;re NOT saying that all applications are on all boxes and that their
data, like the version they&rsquo;re using, is different. We&rsquo;re actually saying that
different machines require entirely different applications).</p>

<p>Using Hiera + create_resources() you could enter the resource for the
application1 at a low level, then, at a higher level, add the resource for
application2, and finally add the resource for application3 at the
node-specific level. In the end, you can do a hiera_hash() lookup to discover
and concatenate all resources from all levels of the hierarchy and pipe that to
create_resources.</p>

<p>How would you do this with Puppet code?  Well, I would create profiles for every
application, and either different roles for the different kinds of servers (i.e.
the snowflake machine gets its own role), or conditional checks inside the role
(i.e. if this node is at the London location, it gets these application profiles,
and etc&hellip;).</p>

<p>Now which is more legible? At this point, I&rsquo;d still say that separate profiles
and conditional checks in roles (or sub-roles) are more legible &ndash; including
a class is a logical thing to follow, and conditionals inside Puppet code are
easy to follow. The create_resources() solution just becomes magic. Suddenly,
applications are on the node. If you want to know where they came from, you
have to switch contexts and open Hiera data files or use the <code>hiera</code> binary
and do a debug run. If you&rsquo;re a small team that&rsquo;s been using Puppet forever,
then rock on and go for it. If you&rsquo;re just getting started, though, I&rsquo;d shy
away.</p>

<h3>Final word on create_resources?</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Some people, when confronted with a problem, think â€œI know, I&rsquo;ll use create_resources().&ldquo;
</span><span class='line'>Now they have two problems.</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The create_resources() function is often called the &ldquo;PSE Swiss Army knife&rdquo;
(or, Professional Services Engineer &ndash; the people who do what
I do and consult with our customers) because we like to break it out when we&rsquo;re
painted into a corner by customer requirements. It will work ANYWHERE, but, again,
at that cost of visibility. I am okay with someone using it so long as they
understand the cost of visibility and the potential debugging issues they&rsquo;ll hit.
I will always argue against using it, however, for those reasons. More code in
a Puppet manifest is not a bad thing&hellip;especially if it&rsquo;s reasonably legible
code that can be kept to a specific class. Consider the needs and experience
level of your team before using create_resources() &ndash; if you don&rsquo;t have a good
reason for using it, simply don&rsquo;t.</p>

<h3>create_resources()</h3>

<p><strong>PROS:</strong></p>

<ul>
<li>Dynamically iterate and create resources based on Hiera data</li>
<li>Using Hiera&rsquo;s hash merging capability, you can functionally override resource values at higher levels of the hierarchy</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Decreased visibility</li>
<li>Becomes a second &lsquo;source of truth&rsquo; to Puppet</li>
<li>Can increase confusion about WHERE to manage resources</li>
<li>When used too much, it creates a DSL to Puppet&rsquo;s DSL (DSLs all the way down)</li>
</ul>


<h3>Puppet DSL + single Hiera lookup</h3>

<p><strong>PROS:</strong></p>

<ul>
<li>More visible (sans the bit of data you&rsquo;re looking up)</li>
<li>Using wrapper classes allows for flexibility and conditional inclusion of resources/classes</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Very explicit &ndash; doesn&rsquo;t have the dynamic overriding capability like Hiera does</li>
</ul>


<h2>Using Hiera as an ENC</h2>

<p>One of the early &ldquo;NEAT!&rdquo; moments everyone has with Hiera is using it as an
External Node Classifier, or ENC. There is a function called <code>hiera_include()</code>
that allows you to include classes into the catalog as if you were to write
&ldquo;include (classname)&rdquo; in a Puppet manifest.  It works like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>london.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; profiles::london::base</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; profiles::london::network</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>dev.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; profiles::tomcat::application2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>site.pp</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="kd">node</span> <span class="s">default</span> <span class="p">{</span>
</span><span class='line'>  <span class="nf">hiera_include</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">classes</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Given the above example, the hiera_include() function will search every level
of the hierarchy looking for a parameter called &lsquo;classes&rsquo;. It returns
a concatenated list of classnames, which it then passes to Puppet&rsquo;s include()
function (in the end, Puppet will declare the profiles::london::base,
profiles::london::network, and profiles::tomcat::application2 classes). Puppet
puts the contents of these classes into the catalog, and away we go. This is
awesome because you can change the classification of a node conditionally
according to a Hiera lookup, and it&rsquo;s terrible because you can CHANGE THE
CLASSIFICATION OF A NODE CONDITIONALLY ACCORDING TO A HIERA LOOKUP!  This means
that anyone with access to the repo holding your Hiera data files can affect
changes to every node in Puppet just by modifying a magical key. It also means
that in order to see the classification for a node, you need to do a Hiera
lookup (i.e. you can&rsquo;t just open a file and see it).</p>

<p>Remember that WHOLE blog post about Roles and Profiles?  I do, because I wrote
the damn thing. <a href="http://bit.ly/puppetworkflows2">You can even go back and read it again, too, if you want to.</a>
One of the core tenets of that article was that each node get classified with a
single role. If you adhere to that (and you should; it makes for a much more
logical Puppet deployment), a node really only ever needs to be classified
ONCE. You don&rsquo;t NEED this conditional classification behavior. It&rsquo;s one of those
&ldquo;It seemed like a good idea at the time&rdquo; moments that I assure you will pass.</p>

<p>Now, you CAN use Roles with hiera_include() &ndash; simply create a Facter fact that
returns the node&rsquo;s role, add a level to the Hiera hierarchy for this role fact,
and in the role&rsquo;s YAML file in Hiera, simply do:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>appserver.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">role::application_server</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Then you can use the same hiera_include() call in the default node definition
in <code>site.pp</code>. The ONLY time I recommend this is if you don&rsquo;t already have some
other classification method. The downside of this method is that if your role
fact CHANGES, for some reason or another, classification immediately changes.
Facts are NOT secure &ndash; they can be overridden really easily. I don&rsquo;t like to
leave classification to an insecure method that anyone with root access on a
machine can change. Using an ENC or <code>site.pp</code> for classification means that the
node ABSOLUTELY CANNOT override its classification. It&rsquo;s the difference between
being authoritative and simply &lsquo;suggesting&rsquo; a classification.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Dynamic classification: no need to maintain a site.pp file or group in the Console</li>
<li>Fact-based: a node&rsquo;s classification can change immediately when its role fact does</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Decreased visibility: need to do a Hiera lookup to determine classification</li>
<li>Insecure: since facts are insecure and can be overridden, so can classification</li>
</ul>


<h2>Data Bindings</h2>

<p>In Puppet 3, we introduced the concept of &lsquo;data bindings&rsquo; for parameterized classes,
which meant that Puppet now had another choice for gathering parmeter values.
Previously, the order Puppet would look to assign a value for parameters to
classes was:</p>

<ol>
<li>A value passed to the class via the parameterized class syntax</li>
<li>A default value provided by the class</li>
</ol>


<p>As of Puppet 3, this is the new parameter assignment order:</p>

<ol>
<li>A value passed to the class via the parameterized class syntax</li>
<li>A Hiera lookup for <em>classname::parametername</em></li>
<li>A default value provided by the class</li>
</ol>


<p>Data bindings is meant to be pluggable to allow for ANY data backend, but,
as of this writing, there&rsquo;s currently only one: Hiera.  Because of this,
Puppet will now automatically do a Hiera lookup for every parameter to a
parameterized class that isn&rsquo;t explicitly passed a value via the parameterized
class syntax (which means that if you just do <code>include classname</code>, Puppet
will do a Hiera lookup for EVERY parameter defined to the &ldquo;classname&rdquo; class).</p>

<p>This is really cool because it means that you can just add <em>classname::parametername</em>
to your Hiera setup, and, as long as you&rsquo;re not EXPLICITLY passing that
parameter&rsquo;s value to the class, Puppet will do a lookup and find the value.</p>

<p>It&rsquo;s also completely transparent to you unless you know it&rsquo;s happening.</p>

<p>The issue here is that this is new functionality to Puppet, and it feels like
magic to me. You can make the argument and say &ldquo;If you don&rsquo;t start using it,
Gary, people will never take to it,&rdquo; however I feel like this kind of magical
lookup in the background is always going to be a bad thing.</p>

<p>There&rsquo;s also another problem.  Consider a Hiera hierarchy that has 15 levels
(they exist, TRUST ME).  What happens if you don&rsquo;t define ANY parameters in
Hiera in the form of <em>classname::parametername</em> and simply want to rely on
the default values for every class?  Well, it means that Hiera is STILL going
to be triggered for every parameter to a class that isn&rsquo;t explicitly passed a
value.  That&rsquo;s a hell of a performance hit.  Fortunately, there&rsquo;s a way to
disable this lookup.  Simply add the following to the Puppet master&rsquo;s <code>puppet.conf</code>
file:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>data_binding_terminus = none</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It&rsquo;s going to be up to how your team needs to work as to whether you use Hiera
data bindings or not. If you have a savvy team that feels they can debug these
lookups, then cool &ndash; use the hell out of it. I prefer to err on the side of an
explicit hiera() lookup for every value I&rsquo;m querying, even if it&rsquo;s a lot of extra
lines of code. I prefer the visibility, especially for new members to your team.
For those people with large hierarchies, you may want to weigh the performance
hit.  Try to disable data bindings and see if your master is more performant. If
so, then explicit hiera() calls may actually buy you some rewards.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Adding parameters to Hiera in the style of <em>classname::parametername</em> will set parameterized class values automatically</li>
<li>Simplified code &ndash; simply use the include() function everywhere (which is safer than the parameterized class syntax)</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Lookup is completely transparent unless you know what&rsquo;s going on</li>
<li>Debugging parameter values can be difficult (especially with typos or forgetting to set values in Hiera)</li>
<li>Performance hit for values you want to be assigned the class default value</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puppetconf 2014 Talk - The Refactor Dance]]></title>
    <link href="http://garylarizza.com/blog/2014/10/23/puppetconf-2014-talk/"/>
    <updated>2014-10-23T15:15:42+02:00</updated>
    <id>http://garylarizza.com/blog/2014/10/23/puppetconf-2014-talk</id>
    <content type="html"><![CDATA[<p>This year at Puppetconf 2014, I presented a 1.5 hour talk entitled &ldquo;The Refactor
Dance&rdquo; that comprised nearly EVERYTHING that I&rsquo;ve written about in my Puppet
Workflows series (from writing better component modules, to Roles/Profiles,
to Workflow, and lots of stories in-between) as well as a couple of bad words,
a pair of leather pants (trousers), and an Uber story that beats your Uber
story. It&rsquo;s long, informative, and you get to watch the sweat stains under my
arms grow in an attractive grey Puppet Labs shirt.  What&rsquo;s not to love?</p>

<p><a href="https://puppetlabs.com/presentations/workshop-doing-refactor-dance-making-your-puppet-modules-more-modular-gary-larizza">To watch the video, click here to check it out!</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Dependencies and Order]]></title>
    <link href="http://garylarizza.com/blog/2014/10/19/on-dependencies-and-order/"/>
    <updated>2014-10-19T15:09:53+02:00</updated>
    <id>http://garylarizza.com/blog/2014/10/19/on-dependencies-and-order</id>
    <content type="html"><![CDATA[<p>This blog post was born out of a number of conversations that I&rsquo;ve had about
Puppet, its dependency model, and why &lsquo;ordering&rsquo; is not necessarily the way to
think about dependencies when writing Puppet manifests. Like most everything on
this site, I&rsquo;m getting it down in a file so I don&rsquo;t have to repeat this all over
again the next time someone asks. Instead, I can point them to this page (and,
when they don&rsquo;t actually <strong>READ</strong> this page, I can end up explaining everything
I&rsquo;ve written here anyways&hellip;).</p>

<p>Before we go any further, let me define a couple of terms:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dependencies     &ndash; In a nutshell, what happens when you use the metaparameters of&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               'before', 'require', 'subscribe' or 'notify' on resources in a
</span><span class='line'>               Puppet manifest: it's a chain of resources that are to be
</span><span class='line'>               evaluted in a specific order every time Puppet runs. Any failure
</span><span class='line'>               of a resource in this chain stops Puppet from evaluating the
</span><span class='line'>               remaining resources in the chain.
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>evaluate         &ndash; When Puppet determines the &lsquo;is&rsquo; value (or current state) of a&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               resource (i.e. for package resources, "is the package installed?")
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>remediate        &ndash; When Puppet determines that the &lsquo;is&rsquo; value (or current state of&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               the resource) is different from the 'should' value (or the value
</span><span class='line'>               entered into the Puppet manifest...the way the resource SHOULD
</span><span class='line'>               end up looking on the system) and Puppet needs to make a change.
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>declarative(ish) &ndash; When I use the word &lsquo;declarative(ish)&rsquo;, I mean that the order&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               by which Puppet evaluates resources that do not contain dependencies
</span><span class='line'>               does not have a set procedure/order. The way Puppet EVALUATES
</span><span class='line'>               resources does not have a set procedure/order, but the order
</span><span class='line'>               that Puppet reads/parses manifest files IS from top-to-bottom
</span><span class='line'>               (which is why variables in Puppet manifests need to be declared
</span><span class='line'>               before they can be used).
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Why Puppet doesn&rsquo;t care about execution order (until it does)</h2>

<p>The biggest shock to the system when getting started with a declarative (ish)
configuration management tool like Puppet is understanding that Puppet describes
the end-state of the machine, and NOT the order that it&rsquo;s (Puppet) going to
take you to that state. To Puppet, the order that it chooses to affect change
in any resource (be it a file to be corrected, a package to be installed, or
any other resource type) is entirely arbitrary because resources that have no
relationship to another resource shouldn&rsquo;t CARE about the order in which they&rsquo;re
evaluated and remediated.</p>

<p>For example, imagine Puppet is going to create both <code>/etc/sudoers</code> and update
the system&rsquo;s authorized keys file to enter all the sysadmins' SSH keys. Which
one should it do first? In an imperative system like shell scripts or
a runbook-style system, you are forced to choose an order. So I ask again,
which one goes first? If you try to update the <code>sudoers</code> file in your script
first, and there&rsquo;s a problem with that update, then the script fails and the
SSH keys aren&rsquo;t installed. If you switch the order and there&rsquo;s a problem with
the SSH keys, then you can&rsquo;t <code>sudo</code> up because the <code>sudoers</code> file hasn&rsquo;t been
touched.</p>

<p>Because of this, Puppet has always taken the stance that if there are failures,
we want to get as much of the system into a working state as possible (i.e. any
resources that don&rsquo;t depend upon the failing resource are going to still be
evaluated, or &lsquo;inspected&rsquo;, and remediated, or &lsquo;changed if need be&rsquo;). There are
definitely philosophical differences here: the argument can be made that if there&rsquo;s
a failure somewhere, the system is bad and you should cast it off until you&rsquo;ve
fixed whatever the problem is (or the part of the code causing the problem). In
virtualized or &lsquo;cloud&rsquo; environments where everything is automated, this is just
fine, but in environments without complete and full automation, sometimes you
have to fix and deal with what you have. Puppet &ldquo;believes in your system&rdquo;, which
is borderline marketing-doubletalk for &ldquo;alert you of errors and give you time
to fix the damn thing and do another Puppet run without having to spin up a whole
new system.&rdquo;</p>

<p>Once you know WHY Puppet takes the stance it does, you realize that Puppet does
not give two shits about the order of resources without dependencies. If you
write perfect Puppet code, you&rsquo;re fine. But the majority of the
known-good-world does not do that. In fact, most of us write shit code. Which
was the problem&hellip;</p>

<h2>The history of Puppet&rsquo;s ordering choices</h2>

<h3>&lsquo;Random&rsquo; random order</h3>

<p>In the early days, the only resources that were guaranteed to have a consistent
order were those resources with dependencies (i.e. as I stated above, resources
that used the &lsquo;before&rsquo;, &lsquo;require&rsquo;, &lsquo;subscribe&rsquo;, or &lsquo;notify&rsquo; metaparameters to
establish an evaluation order). Every other resource was evaluted at random
every time that Puppet ran&hellip;which meant that you could run Puppet ten times
and, theoretically, resources without dependencies could be evaluated in
a different order between every Puppet run (we call this non-deterministic
ordering). This made things REALLY hard to debug.  Take the case where you had
a catalog of thousands of resources but you forgot a SINGLE dependency between
a couple of file resources. If you roll that change out to 1000 nodes, you
might have 10 or less of them fail (because Puppet chose an evaluation order
that ordered these two resources incorrectly). Imagine trying to figure out
what happened and replicate the problem. You could waste lots of time just
trying to REPLICATE the issue, even if it was a small fix like this.</p>

<p><strong>PROS</strong>:</p>

<ul>
<li>IS there a pro here?</li>
</ul>


<p><strong>CONS</strong>:</p>

<ul>
<li>Ordering could change between runs, and thus it was very hard to debug missing dependencies</li>
</ul>


<p>Philosophically, we were correct: resources that are to be evaluated in a certain
order require dependencies. Practically, we were creating more work for ourselves.</p>

<p>Incidentally, I&rsquo;d heard that Adam Jacob, who created Chef, had cited this reason
as one of the main motivators for creating Chef. I&rsquo;d heard that as a Puppet
consultant, he would run into these buried dependency errors and want to flip
tables. Even if it&rsquo;s not a true STORY, it was absolutely true for tables where
I used to work&hellip;</p>

<h3>Title-hash, &lsquo;Predictable&rsquo; random order</h3>

<p>Cut to Puppet version 2.7 where we introduced deterministic ordering with
&lsquo;title-hash&rsquo; ordering. In a nutshell, resources that didn&rsquo;t have dependencies
would still be executed in a random order, but the order Puppet chose could be
replicated (it created a SHA1 hash based on the titles of the resources without
dependencies, and ordered the hashes alphabetically). This meant that if you
tested out a catalog on a node, and then ran that same catalog on 1000 other
nodes, Puppet would choose the same order for all 1000 of the nodes. This
gave you the ability to actually TEST whether your changes would successfully
run in production. If you omitted a dependency, but Puppet managed to pick the
correct evaluation order, you STILL had a missing dependency, but you didn&rsquo;t
care about it because the code worked. The next change you made to the catalog
(by adding or removing resources), the order might change, but you would
discover and fix the dependency at that time.</p>

<p><strong>PROS</strong>:</p>

<ul>
<li>&lsquo;Predictable&rsquo; and repeatable order made testing possible</li>
</ul>


<p><strong>CONS</strong>:</p>

<ul>
<li>Easy to miss dependency omissions if Puppet chose the right order (but do you really care?)</li>
</ul>


<h3>Manifest ordering, the &lsquo;bath salts&rsquo; of ordering</h3>

<p>Title-hash ordering seemed like the best of both worlds &ndash; being opinionated about
resource dependencies but also giving sysadmins a reliable, and repeatable, way
to test evaluation order before it&rsquo;s pushed out to production.</p>

<p>Buuuuuuuuuut, y'all JUST weren&rsquo;t happy enough, were you?</p>

<p>When you move from an imperative solution like scripts to a declarative(ish)
solution like Puppet, it is absolutely a new way to think about modeling your
system. Frequently we heard that people were having issues with Puppet because
the order that resources shows up in a Puppet master WASN&rsquo;T the order that Puppet
would evaluate the resources. I just dropped a LOT of words explaining why this
isn&rsquo;t the case, but who really has the time to read up on all of this? People
were dismissing Puppet too quickly because their expectations of how the tool
worked didn&rsquo;t align with reality. The assumption, then, was to align these
expectations in the hopes that people wouldn&rsquo;t dismiss Puppet so quickly.</p>

<p><a href="http://puppetlabs.com/blog/introducing-manifest-ordered-resources">Eric Sorenson wrote a blog post on our thesis and experimentation</a>
around manifest ordering that is worth a read (and, incidentally, is shorter
than this damn post), but the short version is that we tested this theory out
and determined that Manifest Ordering would help new users to Puppet. Because
of this work, we created a feature called &lsquo;Manifest Ordering&rsquo; that stated that
resources that DID NOT HAVE DEPENDENCIES would be evaluated by Puppet in the
order that they showed up in the Puppet manifest (when read top to bottom). If
a resource truly does not have any dependencies, then you honestly should not
care one bit what order it&rsquo;s evaluated (because it doesn&rsquo;t matter).  Manifest
Ordering made ordering of resources without dependencies VERY predictable.</p>

<p>But&hellip;.</p>

<p>This doesn&rsquo;t mean I think it&rsquo;s the best thing in the world. In fact, I&rsquo;m really
wary of how I feel people will come to use Manifest Ordering. There&rsquo;s a reason
I called it the &ldquo;bath salts of ordering&rdquo; &ndash; because a little bit of it, when
used correctly, can be a lovely thing, but too much of it, used in unintended
circumstances, leads to hypothermia, paranoia, and the desire to gnaw someone
else&rsquo;s face off. We were/are giving you a way to bypass our dependency model by
using the mental-model you had with scripts, but ALSO telling you NOT to rely
on that mental-model (and instead set dependencies explicitly using metaparameters).</p>

<p>Seriously, what could go wrong?</p>

<p>Manifest Ordering is not a substitution for setting dependencies &ndash; that IS NOT
what it was created for. <strong>Puppet Labs still maintains that you should use
dependencies to order resources and NOT simply rely on Manifest Ordering as
a form of setting dependencies!</strong> Again, the problem is that you need to KNOW
this&hellip;and if Manifest Ordering allows you to keep the same imperative
&ldquo;mindset&rdquo; inside a declarative(ish) language, then eventually you&rsquo;re going to
experience pain (if not today, but possibly later when you actually try to
refactor code, or share code, or use this code on a system that ISN&rsquo;T using
Manifest Ordering). A declarative(ish) language like Puppet requires seeing
your systems according to the way their end-state will look and worrying about
WHAT the system will look like, and not necessarily HOW it will get there. Any
shortcut to understanding this process means you&rsquo;re going to miss key bits of
what makes Puppet a good tool for modeling this state.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Evaluation order of resources without dependencies is absolutely predictable</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>If used as a substitution for setting dependencies, then refactoring code (moving around the order in which resources show up in a manifest) means changing the evaluation order</li>
</ul>


<h2>What should I actually take from this?</h2>

<p>Okay, here&rsquo;s a list of things you SHOULD be doing if you don&rsquo;t want to create
a problem for future-you or future-organization:</p>

<ul>
<li>Use dependency metaparameters like &lsquo;before&rsquo;, &lsquo;require&rsquo;, &lsquo;notify&rsquo;, and &lsquo;subscribe&rsquo; if resources in a catalog NEED to be evaluated in a particular order</li>
<li>Do not use Manifest Ordering as a substitute for explicitly setting dependencies (disable it if this is too tempting)</li>
<li>Use Roles and Profiles for a logical module layout (see: <a href="http://bit.ly/puppetworkflows2">http://bit.ly/puppetworkflows2</a> for information on Roles and Profiles)</li>
<li>Order individual components inside the Profile</li>
<li>Order Profiles (if necessary) inside the Role</li>
</ul>


<p>And, seriously, trust us with the explicit dependencies. It seems like a giant
pain in the ass initially, but you&rsquo;re ultimately documenting your infrastructure,
and a dependency (or, saying &lsquo;this thing MUST come before that thing&rsquo;) is a pretty
important decision. There&rsquo;s a REASON behind it &ndash; treat it with some more weight
other than having one line come before another line, ya know? The extra time
right now is absolutely going to buy you the time you spend at home with your
kids (and by &lsquo;kids&rsquo;, I mean &lsquo;XBox&rsquo;).</p>

<p>And don&rsquo;t use bath salts, folks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R10k + Directory Environments]]></title>
    <link href="http://garylarizza.com/blog/2014/08/31/r10k-plus-directory-environments/"/>
    <updated>2014-08-31T21:00:00+02:00</updated>
    <id>http://garylarizza.com/blog/2014/08/31/r10k-plus-directory-environments</id>
    <content type="html"><![CDATA[<p>If you&rsquo;ve read anything I&rsquo;ve posted in the past year, you know my feelings about
the word &lsquo;environments&rsquo; and about how well we tend to name things here at
Puppet Labs (and if you don&rsquo;t, <a href="http://garylarizza.com/blog/2014/03/26/random-r10k-workflow-ideas/">you can check out that post here</a>).
Since then, Puppet Labs has released a new feature called <a href="https://docs.puppetlabs.com/puppet/latest/reference/environments.html">directory
environments (click this link for further reading)</a>
that replace the older &lsquo;config file environments&rsquo; that we all used to use (i.e.
stanzas in puppet.conf).  Directory environments weren&rsquo;t without their false
starts and issues, but further releases of Puppet, and their inclusion in
Puppet Enterprise 3.3.0, have allowed more people
to ask about them.  SO, I thought I&rsquo;d do a quick writeup about them&hellip;</p>

<h2>R10k had a child: Directory Environments</h2>

<p>The Puppet platform team had a couple of problems with config file environments
in puppet.conf &ndash; namely:</p>

<ul>
<li>Entering them in puppet.conf meant that you couldn&rsquo;t use environments named &lsquo;master&rsquo;, &lsquo;main&rsquo;, or &lsquo;agent&rsquo;</li>
<li>There was no easy/reliable way to determine all the available/used Puppet environments without making assumptions (and hacky code) &ndash; especially if someone were using R10k + dynamic environments</li>
<li>Adding more environments to <code>puppet.conf</code> made managing that file something of a nightmare (<code>environments.d</code> anyone?)</li>
</ul>


<p>Combine this with the fact that <a href="http://bit.ly/puppetworkflows3">most of the Professional Services team was
rolling out R10k to create dynamic environments</a> (which meant we
were abusing <code>$environment</code> inside <code>puppet.conf</code> and creating environments&hellip;well&hellip;
dynamically and on-the-fly), and they knew something needed to be done.
Because R10k was so popular and widely deployed, an environment solution that
was a simple step-up from an R10k deployment was made the target, and directory
environments were born.</p>

<h2>How does it work?</h2>

<p>Directory environments, essentially, are born out of a folder on the Puppet master
(typically <code>$confdir/environments</code>, where <code>$confdir</code> is <code>/etc/puppetlabs/puppet</code>
in Puppet Enterprise) wherein every subfolder is a new Puppet environment. Every
subfolder contains a couple of key items:</p>

<ul>
<li>A <code>modules</code> folder containing all modules for that environment</li>
<li>A <code>manifests/site.pp</code> file containing the site.pp file for that environment</li>
<li>A new <code>environment.conf</code> file which can be used to set the <code>modulepath</code>, the <code>environment_timeout</code>, and, a new and often-requested feature, the ability to have environment-specific <code>config_version</code> settings</li>
</ul>


<p>Basically, it&rsquo;s everything that R10k ALREADY does with a couple of added goodies
dropped into an <code>environment.conf</code> file. <a href="https://docs.puppetlabs.com/puppet/latest/reference/environments_configuring.html">Feel free to read the official docs
on configuring directory environments</a> for further information
on all of the goodies!</p>

<h2>Cool, how do we set it up?</h2>

<p>It wouldn&rsquo;t be one of my blog posts if it didn&rsquo;t include exact steps to configure
shit, would it? For this walkthrough, I&rsquo;m using a Centos 6.5 vm with DNS working
(i.e. the node can ping itself and knows its own hostname and FQDN), and I&rsquo;ve
already installed an All-in-one installation of Puppet Enterprise 3.3.0. For
the walkthrough, we&rsquo;re going to setup:</p>

<ul>
<li>Directory environments based on a control repo</li>
<li>Hiera data inside a <code>hieradata</code> folder in the control repo</li>
<li>Hiera to use the per-environment hieradata folder</li>
</ul>


<p>Let&rsquo;s start to break down the components:</p>

<h3>The &lsquo;Control Repo&rsquo;?</h3>

<p>Sometime between <a href="http://bit.ly/puppetworkflows3">my initial R10k post</a> and THIS post, the Puppet Labs PS
team has come to call the repository that contains the Puppetfile and is used
to track Puppet environments on all Puppet masters the &lsquo;Control Repo&rsquo; (because
it &lsquo;Controls the creation of Puppet environments&rsquo;, ya dig?  Zack Smith and
James Sweeny are actually pretty tickled about making that name stick). For
the purpose of this demonstration, I&rsquo;m using a repository on Github:</p>

<p><a href="https://github.com/glarizza/puppet_repository">https://github.com/glarizza/puppet_repository</a></p>

<p>Everything you will need for this walkthrough is in that repository, and we
will refer to it frequently. You DO NOT need to use my repository, and it&rsquo;s
definitely going to be required that you create your OWN, but it&rsquo;s there
for reference purposes (and to give you a couple of Puppet manifests to
make setup a bit easier).</p>

<h3>Configuring the Puppet master</h3>

<p>We&rsquo;re going to first clone my control repo to <code>/tmp</code> so we can use it to
configure R10k and the Puppet master itself:</p>

<p>```
[root@master ~]# cd /tmp</p>

<p>[root@master /tmp]# git clone <a href="https://github.com/glarizza/puppet_repository.git">https://github.com/glarizza/puppet_repository.git</a>
Initialized empty Git repository in /tmp/puppet_repository/.git/
remote: Counting objects: 164, done.
remote: Compressing objects: 100% (134/134), done.
remote: Total 164 (delta 54), reused 81 (delta 16)
Receiving objects: 100% (164/164), 22.68 KiB, done.
Resolving deltas: 100% (54/54), done.</p>

<p>[root@master /tmp]# cd puppet_repository
```</p>

<p>Great, I&rsquo;ve cloned my repo. To configure R10k, we&rsquo;re going to need to pull
down Zack Smith&rsquo;s R10k module from the forge with <code>puppet module install zack/r10k</code>
and then use <code>puppet apply</code> on a manifest in my repo with
<code>puppet apply configure_r10k.pp</code>.  <strong>DO NOTE: If you want to use YOUR Control
Repo, and NOT the one I use on Github, then you need to modify the
<code>configure_r10k.pp</code> file and replace the <code>remote</code> property with the URL to
YOUR Control Repo that&rsquo;s housed on a git repository!</strong></p>

<p>```
[root@master /tmp/puppet_repository:production]# puppet module install zack/r10k</p>

<p>Notice: Preparing to install into /etc/puppetlabs/puppet/modules &hellip;
Notice: Downloading from <a href="https://forgeapi.puppetlabs.com">https://forgeapi.puppetlabs.com</a> &hellip;
Notice: Found at least one version of puppetlabs-stdlib compatible with PE (3.3.0);
Notice: Skipping versions which don&rsquo;t express PE compatibility. To install
the most recent version of the module regardless of compatibility
with PE, use the &lsquo;&mdash;ignore-requirements&rsquo; flag.
Notice: Found at least one version of puppetlabs-inifile compatible with PE (3.3.0);
Notice: Skipping versions which don&rsquo;t express PE compatibility. To install
the most recent version of the module regardless of compatibility
with PE, use the &lsquo;&mdash;ignore-requirements&rsquo; flag.
Notice: Found at least one version of puppetlabs-vcsrepo compatible with PE (3.3.0);
Notice: Skipping versions which don&rsquo;t express PE compatibility. To install
the most recent version of the module regardless of compatibility
with PE, use the &lsquo;&mdash;ignore-requirements&rsquo; flag.
Notice: Found at least one version of puppetlabs-concat compatible with PE (3.3.0);
Notice: Skipping versions which don&rsquo;t express PE compatibility. To install
the most recent version of the module regardless of compatibility
with PE, use the &lsquo;&mdash;ignore-requirements&rsquo; flag.
Notice: Installing &mdash; do not interrupt &hellip;
/etc/puppetlabs/puppet/modules
â””â”€â”¬ zack-r10k (v2.2.7)
  â”œâ”€â”¬ gentoo-portage (v2.2.0)
  â”‚ â””â”€â”€ puppetlabs-concat (v1.0.3) [/opt/puppet/share/puppet/modules]
  â”œâ”€â”€ mhuffnagle-make (v0.0.2)
  â”œâ”€â”€ puppetlabs-gcc (v0.2.0)
  â”œâ”€â”€ puppetlabs-git (v0.2.0)
  â”œâ”€â”€ puppetlabs-inifile (v1.1.0) [/opt/puppet/share/puppet/modules]
  â”œâ”€â”€ puppetlabs-pe_gem (v0.0.1)
  â”œâ”€â”€ puppetlabs-ruby (v0.2.1)
  â”œâ”€â”€ puppetlabs-stdlib (v3.2.2) [/opt/puppet/share/puppet/modules]
  â””â”€â”€ puppetlabs-vcsrepo (v1.1.0)</p>

<p>[root@master /tmp/puppet_repository:production]# puppet apply configure_r10k.pp</p>

<p>Notice: Compiled catalog for master.puppetlabs.vm in environment production in 0.71 seconds
Warning: The package type&rsquo;s allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /opt/puppet/lib/ruby/site_ruby/1.9.1/puppet/type.rb:816:in `set_default')
Notice: /Stage[main]/R10k::Install/Package[r10k]/ensure: created
Notice: /Stage[main]/R10k::Install::Pe_gem/File[/usr/bin/r10k]/ensure: created
Notice: /Stage[main]/R10k::Config/File[r10k.yaml]/ensure: defined content as &lsquo;{md5}5cda58e8a01e7ff12544d30105d13a2a&rsquo;
Notice: Finished catalog run in 11.24 seconds
```</p>

<p>Performing those commands will successfully setup R10k to point to my Control
Repo out on Github (and, again, if you don&rsquo;t WANT that, then you need to make
the change to the <code>remote</code> property in <code>configure_r10k.pp</code>). We next need to
configure Directory Environments in <code>puppet.conf</code> by setting two attributes:</p>

<ul>
<li><code>environmentpath</code> (Or the path to the folder containing environments)</li>
<li><code>basemodulepath</code> (Or, the set of modules that will be shared across ALL ENVIRONMENTS)</li>
</ul>


<p>I have created a Puppet manifest that will set these attributes, and this
manifest requires the <code>puppetlabs/inifile</code> module from the Puppet Forge.
Fortunately, since I&rsquo;m using Puppet Enterprise, that module is already installed.
If you&rsquo;re using open source Puppet and the module is NOT installed, feel free
to install it by running <code>puppet module install puppetlabs/inifile</code>. Once
this is done, go ahead and execute the manifest by running
<code>puppet apply configure_directory_environments.pp</code>:</p>

<p>```
[root@master /tmp/puppet_repository:production]# puppet apply configure_directory_environments.pp</p>

<p>Notice: Compiled catalog for master.puppetlabs.vm in environment production in 0.05 seconds
Notice: /Stage[main]/Main/Ini_setting[Configure environmentpath]/ensure: created
Notice: /Stage[main]/Main/Ini_setting[Configure basemodulepath]/value: value changed &lsquo;/etc/puppetlabs/puppet/modules:/opt/puppet/share/puppet/modules&rsquo; to &lsquo;$confdir/modules:/opt/puppet/share/puppet/modules&rsquo;
Notice: Finished catalog run in 0.20 seconds
```</p>

<p>The last step to configuring the Puppet master is to execute an R10k run.
We can do that by running <code>r10k deploy environment -pv</code>:</p>

<p>```
[root@master /tmp/puppet_repository:production]# r10k deploy environment -pv</p>

<p>[R10K::Source::Git &ndash; INFO] Determining current branches for &ldquo;<a href="https://github.com/glarizza/puppet_repository.git">https://github.com/glarizza/puppet_repository.git</a>&rdquo;
[R10K::Task::Environment::Deploy &ndash; NOTICE] Deploying environment production
[R10K::Task::Puppetfile::Sync &ndash; INFO] Loading modules from Puppetfile into queue
[R10K::Task::Module::Sync &ndash; INFO] Deploying profiles into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying notifyme into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying ntp into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying apache into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying profiles into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying notifyme into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying ntp into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying apache into /etc/puppetlabs/puppet/environments/production/modules
[R10K::Task::Environment::Deploy &ndash; NOTICE] Deploying environment webinar_env
[R10K::Task::Puppetfile::Sync &ndash; INFO] Loading modules from Puppetfile into queue
[R10K::Task::Module::Sync &ndash; INFO] Deploying profiles into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying notifyme into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying haproxy into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying mysql into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying ntp into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying apache into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying profiles into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying notifyme into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying haproxy into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying mysql into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying ntp into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Module::Sync &ndash; INFO] Deploying apache into /etc/puppetlabs/puppet/environments/webinar_env/modules
[R10K::Task::Deployment::PurgeEnvironments &ndash; INFO] Purging stale environments from /etc/puppetlabs/puppet/environments
```</p>

<p>Great!  Everything should be setup (if you&rsquo;re using my repo)!  My repository has
a production branch, which is what Puppet&rsquo;s default environment is named,
so we can test that everything works by listing out all modules in the main
production environment with the <code>puppet module list</code> command:</p>

<p>```
[root@master /tmp/puppet_repository:production]# puppet module list</p>

<p>Warning: Module &lsquo;puppetlabs-stdlib&rsquo; (v3.2.2) fails to meet some dependencies:
  &lsquo;puppetlabs-ntp&rsquo; (v3.1.2) requires &lsquo;puppetlabs-stdlib&rsquo; (>= 4.0.0)
/etc/puppetlabs/puppet/environments/production/modules
â”œâ”€â”€ notifyme (???)
â”œâ”€â”€ profiles (???)
â”œâ”€â”€ puppetlabs-apache (v1.1.1)
â””â”€â”€ puppetlabs-ntp (v3.1.2)
/etc/puppetlabs/puppet/modules
â”œâ”€â”€ gentoo-portage (v2.2.0)
â”œâ”€â”€ mhuffnagle-make (v0.0.2)
â”œâ”€â”€ puppetlabs-gcc (v0.2.0)
â”œâ”€â”€ puppetlabs-git (v0.2.0)
â”œâ”€â”€ puppetlabs-pe_gem (v0.0.1)
â”œâ”€â”€ puppetlabs-ruby (v0.2.1)
â”œâ”€â”€ puppetlabs-vcsrepo (v1.1.0)
â””â”€â”€ zack-r10k (v2.2.7)
/opt/puppet/share/puppet/modules
â”œâ”€â”€ puppetlabs-apt (v1.5.0)
â”œâ”€â”€ puppetlabs-auth_conf (v0.2.2)
â”œâ”€â”€ puppetlabs-concat (v1.0.3)
â”œâ”€â”€ puppetlabs-firewall (v1.1.2)
â”œâ”€â”€ puppetlabs-inifile (v1.1.0)
â”œâ”€â”€ puppetlabs-java_ks (v1.2.4)
â”œâ”€â”€ puppetlabs-pe_accounts (v2.0.2-3-ge71b5a0)
â”œâ”€â”€ puppetlabs-pe_console_prune (v0.1.1-4-g293f45b)
â”œâ”€â”€ puppetlabs-pe_mcollective (v0.2.10-15-gb8343bb)
â”œâ”€â”€ puppetlabs-pe_postgresql (v1.0.4-4-g0bcffae)
â”œâ”€â”€ puppetlabs-pe_puppetdb (v1.1.1-7-g8cb11bf)
â”œâ”€â”€ puppetlabs-pe_razor (v0.2.1-1-g80acb4d)
â”œâ”€â”€ puppetlabs-pe_repo (v0.7.7-32-gfd1c97f)
â”œâ”€â”€ puppetlabs-pe_staging (v0.3.3-2-g3ed56f8)
â”œâ”€â”€ puppetlabs-postgresql (v2.5.0-pe2)
â”œâ”€â”€ puppetlabs-puppet_enterprise (v3.2.1-27-g8f61956)
â”œâ”€â”€ puppetlabs-reboot (v0.1.4)
â”œâ”€â”€ puppetlabs-request_manager (v0.1.1)
â””â”€â”€ puppetlabs-stdlib (v3.2.2)  invalid
```</p>

<p>Notice a couple of things:</p>

<ul>
<li>First, I&rsquo;ve got some dependency issues&hellip;oh well, nothing that&rsquo;s a game-stopper</li>
<li>Second, the path to the production environment&rsquo;s module is correct at: <code>/etc/puppetlabs/puppet/environments/production/modules</code></li>
</ul>


<h3>Configuring Hiera</h3>

<p>The last dinghy to be configured on this dreamboat is Hiera. Hiera is Puppet&rsquo;s
data lookup mechanism, and is used to gather specific bits of data (such
as versions of packages, hostnames, passwords, and other business-specific
data). Explaining HOW Hiera works is beyond the scope of this article, but
configuring Hiera data on a per-environment basis IS absolutely a worthwhile
endeavor.</p>

<p>In this example, I&rsquo;m going to demonstrate coupling Hiera data with the Control
Repo for simple replication of Hiera data across environments. You COULD also
choose to put your Hiera data in a separate repository and set it up in
<code>/etc/r10k.yaml</code> as another source, but that exercise is left to the reader
<a href="http://bit.ly/puppetworkflows3b">(and if you&rsquo;re interested, I talk about it in this post).</a></p>

<p>You&rsquo;ll notice that my demonstration repository ALREADY includes Hiera data,
and so that data is automatically being replicated to all environments. By
default, Hiera&rsquo;s configuration file (<code>hiera.yaml</code>) has no YAML data directory
specified, so we&rsquo;ll need to make that change.  <a href="https://github.com/glarizza/puppet_repository/blob/production/hiera.yaml">In my demonstration control
repository, I&rsquo;ve included a sample <code>hiera.yaml</code>,</a> but let&rsquo;s take a look at
one below:</p>

<p>```yaml</p>

<h2>/etc/puppetlabs/puppet/hiera.yaml</h2>

<hr />

<p>:backends:
  &ndash; yaml
:hierarchy:
  &ndash; &ldquo;%{clientcert}&rdquo;
  &ndash; &ldquo;%{application_tier}&rdquo;
  &ndash; common</p>

<p>:yaml:</p>

<h1>datadir is empty here, so hiera uses its defaults:</h1>

<h1>&ndash; /var/lib/hiera on *nix</h1>

<h1>&ndash; %CommonAppData%\PuppetLabs\hiera\var on Windows</h1>

<h1>When specifying a datadir, make sure the directory exists.</h1>

<p>  :datadir: &ldquo;/etc/puppetlabs/puppet/environments/%{environment}/hieradata&rdquo;
```</p>

<p>This hiera.yaml file specifies a hierarchy with three levels &ndash; a node-specific,
level, a level for different application tiers (like &lsquo;dev&rsquo;, &lsquo;test&rsquo;, &lsquo;prod&rsquo;, and
etc), and finally makes the change we need: mapping the data directory to each
environment&rsquo;s hieradata folder.  The path to <code>hiera.yaml</code> is Puppet&rsquo;s
configuration directory (which is <code>/etc/puppetlabs/puppet</code> for Puppet
Enterprise, or <code>/etc/puppet</code> for the open source version of Puppet), so open
the file there, make your changes, and finally you&rsquo;ll need to need to restart
the Puppet master service to have the changes picked up.</p>

<p>Next, let&rsquo;s perform a test by executing the <code>hiera</code> binary from the command
line before running puppet:</p>

<p>```
[root@master /etc/puppetlabs/puppet/environments]# hiera message environment=production
This node is using common data</p>

<p>[root@master /etc/puppetlabs/puppet/environments]# hiera message environment=webinar_env -d
DEBUG: 2014-08-31 19:55:44 +0000: Hiera YAML backend starting
DEBUG: 2014-08-31 19:55:44 +0000: Looking up message in YAML backend
DEBUG: 2014-08-31 19:55:44 +0000: Looking for data source common
DEBUG: 2014-08-31 19:55:44 +0000: Found message in common
This node is using common data</p>

<p>[root@master /etc/puppetlabs/puppet/environments]# hiera message environment=bad_env -d
DEBUG: 2014-08-31 19:58:22 +0000: Hiera YAML backend starting
DEBUG: 2014-08-31 19:58:22 +0000: Looking up message in YAML backend
DEBUG: 2014-08-31 19:58:22 +0000: Looking for data source common
DEBUG: 2014-08-31 19:58:22 +0000: Cannot find datafile /etc/puppetlabs/puppet/environments/bad_env/hieradata/common.yaml, skipping
nil
```</p>

<p>You can see that for the first example, I passed the environment of <code>production</code>
and did a simple lookup for a key called <code>message</code> &ndash; Hiera then returned me
the value of out that environment&rsquo;s <code>common.yaml</code> file.  Next, I did another
lookup, but added <code>-d</code> to enable debug mode (debug mode on the <code>hiera</code>
binary is REALLY handy for debugging problems with Hiera &ndash; combine it with
specifying values from the command line, and you can pretty quickly simulate
what value a node is going to get).  Notice the last example where I specified
an invalid environment &ndash; Hiera logged that it couldn&rsquo;t find the datafile
requested and ultimately returned a nil, or empty, value.</p>

<p>Since we&rsquo;re working on the Puppet master machine, we can even check for a value
using <code>puppet apply</code> combined with the notice function:</p>

<p><code>
[root@master /etc/puppetlabs/puppet/environments]# puppet apply -e "notice(hiera('message'))"
Notice: Scope(Class[main]): This node is using common data
Notice: Compiled catalog for master.puppetlabs.vm in environment production in 0.09 seconds
Notice: Finished catalog run in 0.19 seconds
</code></p>

<p>Great, it&rsquo;s working, but let&rsquo;s look at pulling data from a higher level in the
hierarchy &ndash; like from the <code>application_tier</code> level. We haven&rsquo;t defined an
<code>application_tier</code> fact, however, so we&rsquo;ll need to fake it. First, let&rsquo;s do
that with the <code>hiera</code> binary:</p>

<p><code>
[root@master /etc/puppetlabs/puppet/environments]# hiera message environment=production application_tier=dev -d
DEBUG: 2014-08-31 20:04:12 +0000: Hiera YAML backend starting
DEBUG: 2014-08-31 20:04:12 +0000: Looking up message in YAML backend
DEBUG: 2014-08-31 20:04:12 +0000: Looking for data source dev
DEBUG: 2014-08-31 20:04:12 +0000: Found message in dev
You are in the development application tier
</code></p>

<p>And then also with <code>puppet apply</code>:</p>

<p><code>
[root@master /etc/puppetlabs/puppet/environments]# FACTER_application_tier=dev puppet apply -e "notice(hiera('message'))"
Notice: Scope(Class[main]): You are in the development application tier
Notice: Compiled catalog for master.puppetlabs.vm in environment production in 0.09 seconds
Notice: Finished catalog run in 0.18 seconds
</code></p>

<h2>Tuning <code>environment.conf</code></h2>

<p>The brand-new, per-environment  <code>environment.conf</code> file is meant to be (for
the most part) a one-stop-shop for your Puppet environment tuning needs. Right
now, the only things you&rsquo;ll need to tune will be the <code>modulepath</code>,
<code>config_version</code>, and possibly the <code>environment_timeout</code>.</p>

<h3>Module path</h3>

<p>Before directory environments, every environment had its own <code>modulepath</code> that
needed to be tuned to allow for modules that were to be used by this
machine/environment, as well as shared modules.  That <code>modulepath</code> worked like
<code>$PATH</code> in that it was a priority-based lookup for modules (i.e. the first
directory in <code>modulepath</code> that had a module matching the module name you wanted
won).  It also previously required the FULL path to be used for every path in
<code>modulepath</code>.</p>

<p>Those days are over.</p>

<p>As I mentioned before, the main <code>puppet.conf</code> configuration file has a new
parameter called <code>basemodulepath</code> that can be used to specify modules that are
to be shared across ALL modules in ALL environments. Paths defined here
(typically <code>$confdir/modules</code> and <code>/opt/puppet/share/puppet/modules</code>) are
usually put at the END of a <code>modulepath</code> so Puppet can search for any
overridden modules that show up in earlier <code>modulepath</code> paths. In the previous
configuration steps, we executed a manifest that setup <code>basemodulepath</code> to
look like:</p>

<p><code>
basemodulepath = $confdir/modules:/opt/puppet/share/puppet/modules
</code></p>

<p>Again, feel free to add or remove paths (except don&rsquo;t remove
<code>/opt/puppet/share/puppet/modules</code> if you&rsquo;re using Puppet Enterprise, because
that&rsquo;s where all Puppet Enterprise modules are located), especially if you&rsquo;re
using a giant monolithic repo of modules (which was typically done before things
like R10k evolved).</p>

<p>With <code>basemodulepath</code> configured, it&rsquo;s now time to configure the <code>modulepath</code>
to be defined for every environment. My demonstration control repo contains
a sample <code>environment.conf</code> that defines a <code>modulepath</code> like so:</p>

<p><code>
modulepath = modules:$basemodulepath
</code></p>

<p>You&rsquo;ll notice, now, that there are relative paths in <code>modulepath</code>. This is
possible because now each environment contains an <code>environment.conf</code>, and thus
relative paths make sense. In this example, nodes in the production environment
(<code>/etc/puppetlabs/puppet/environments/production</code>) will look for a module by its
name FIRST by looking in a folder called <code>modules</code> inside the current
environment folder (i.e. <code>/etc/puppetlabs/puppet/environments/production/modules/&lt;module_name&gt;</code>).
If the module wasn&rsquo;t found there, it looks for the module in the order that
paths are defined for <code>basemodulepath</code> above. If Puppet fails to find a module
in ANY of the paths, a compile error is raised.</p>

<h3>Per-environment <code>config_version</code></h3>

<p><a href="https://docs.puppetlabs.com/references/stable/configuration.html#configversion">Setting <code>config_version</code> has been around for awhile</a> &ndash; hell,
I remember video of Jeff McCune talking about it at the first Puppetcamp Europe
in like 2010 &ndash; but the new directory environments implementation has fine
tuned it a bit. Previously, <code>config_version</code> was a command executed on the
Puppet master at compile time to determine a string used for versioning the
configuration enforced during that Puppet run. When it&rsquo;s not set it defaults
to something of a time/date stamp off the parser, but it&rsquo;s way more useful to
make it do something like determine the most recent commit hash from a repository.</p>

<p>In the past when we used a giant monolithic repository containing all Puppet
modules, it was SUPER easy to get a single commit hash and be done. As everyone
moved their modules into individual repositories, determining <em>WHAT</em> you were
enforcing became harder. With the birth of R10k an the control repo, we
suddenly had something we could query for the state of our modules being
enforced. The problem existed, though, that with multiple dynamic environments
using multiple git branches, <code>config_version</code> wasn&rsquo;t easily tuned to be able
to grab the most recent commit from every branch.</p>

<p>Now that <code>config_version</code> is set in a per-environment <code>environment.conf</code>, we
can make <code>config_version</code> much smarter. Again, looking in the <code>environment.conf</code>
defined in my demonstration control repo produces this:</p>

<p><code>
config_version = '/usr/bin/git --git-dir $confdir/environments/$environment/.git rev-parse HEAD'
</code></p>

<p>This setting will cause the Puppet master to produce the most recent commit ID
for whatever environment you&rsquo;re in and embed it in the catalog and the report
that is sent back to the Puppet master after a Puppet run.</p>

<p><a href="https://tickets.puppetlabs.com/browse/PUP-3150">I actually discovered a bug in <code>config_version</code> while writing this post</a>,
and it&rsquo;s that <code>config_version</code> is subject to the relative pathing fun that other
<code>environment.conf</code> settings are subject to. Relative pathing is great for things like
<code>modulepath</code>, and it&rsquo;s even good for <code>config_version</code> if you&rsquo;re including the
script you want to run to gather the <code>config_version</code> string inside the control
repo, but using a one-line command that tries to execute a binary on the system
that DOESN&rsquo;T include the full path to the binary causes an error (because Puppet
attempts to look for that binary in the current environment path, and NOT by
searching <code>$PATH</code> on the system).  Feel free to follow or comment on the bug
if the mood hits you.</p>

<h3>Caching and environment_timeout</h3>

<p>The Puppet master loads environments on-request, but it also caches data associated
with each environment to make things faster. This caching is finally tunable on a
per-environment basis by defining the <code>environment_timeout</code> setting in
<code>environment.conf</code>.  The default setting is 3 minutes, which means the Puppet master
will invalidate its caches and reload environment data every 3 minutes, but that&rsquo;s
now tunable. <a href="https://docs.puppetlabs.com/puppet/3.6/reference/environments_configuring.html#environmenttimeout">Definitely read up on this setting before making changes.</a></p>

<h2>Classification</h2>

<p>One of the last new features of directory environments is the ability to include
an environment-specific <code>site.pp</code> file for classification. You could ALWAYS do
this by modifying the <code>manifest</code> configuration item in <code>puppet.conf</code>, but now
each environment can have its own <code>manifest</code> setting. The default behavior is
to have the Puppet master look for <code>manifests/site.pp</code> in every environment
directory, and I really wouldn&rsquo;t change that unless you have a good reason. DO
NOTE, however, that if you&rsquo;re using Puppet Enterprise, you&rsquo;ll need to be careful
with your <code>site.pp</code> file.  Puppet Enterprise defines things like the Filebucket
and overrides for the File resource in <code>site.pp</code>, so if you&rsquo;re using Puppet Enterprise,
you&rsquo;ll need to copy those changes into the <code>site.pp</code> file you add into your control
repo (as I did).</p>

<p>It may take you a couple of times to change your thinking from looking at the main
<code>site.pp</code> in <code>$confdir/manifests</code> to looking at each environment-specific <code>site.pp</code>
file, but definitely take advantage of Puppet&rsquo;s commandline tool to help you track
which <code>site.pp</code> Puppet is monitoring:</p>

<p>```
[root@master /etc/puppetlabs/puppet/environments]# puppet config print manifest
/etc/puppetlabs/puppet/environments/production/manifests</p>

<p>[root@master /etc/puppetlabs/puppet/environments]# puppet config print manifest &mdash;environment webinar_env
/etc/puppetlabs/puppet/environments/webinar_env/manifests
```</p>

<p>You can see that <code>puppet config print</code> can be used to get the path to the
directory that contains <code>site.pp</code>.  Even cooler is what happens when you
specify an environment that doesn&rsquo;t exist:</p>

<p><code>
[root@master /etc/puppetlabs/puppet/environments]# puppet config print manifest --environment bad_env
no_manifest
</code></p>

<p>Yep, Puppet tells you if it can&rsquo;t find the manifest file.  That&rsquo;s pretty cool.</p>

<h2>Wrapping Up</h2>

<p>Even though the new implementation of directory environments is meant to map
closely to a workflow most of us have been using (if you&rsquo;ve been using R10k, that is),
there are still some new features that may take you by surprise. Hopefully this
post gets you started with just enough information to setup your own test
environment and start playing. PLEASE DO make sure to file bugs on any behavior
that comes as unexpected or stops you from using your existing workflow. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On R10k and 'Environments']]></title>
    <link href="http://garylarizza.com/blog/2014/03/26/random-r10k-workflow-ideas/"/>
    <updated>2014-03-26T09:00:00+01:00</updated>
    <id>http://garylarizza.com/blog/2014/03/26/random-r10k-workflow-ideas</id>
    <content type="html"><![CDATA[<p>There have been more than a couple of moments where I&rsquo;m on-site with a customer
who asks a seemingly simple question and I&rsquo;ve gone &ldquo;Oh shit; that&rsquo;s a great
question and I&rsquo;ve never thought of that&hellip;&rdquo;  Usually that&rsquo;s followed by me
changing up the workflow and immediately regretting things I&rsquo;ve done on prior
gigs. Some people call that &lsquo;agile&rsquo;; I call it &lsquo;me not having the
forethought to consider conditions properly&rsquo;.</p>

<h2>&lsquo;Environment&rsquo;, like &lsquo;scaling&rsquo;, &lsquo;agent&rsquo;, and &lsquo;test&rsquo;, has many meanings</h2>

<p>It&rsquo;s not a secret that we&rsquo;ve made some shitty decisions in the past with regard
to naming things in Puppet (and anyone who asks me what <code>puppet agent -t</code>
stands for usually gets a heavy sigh, a shaken head, and an explanation emitted
in dulcet, apologetic tones). It&rsquo;s also very easy to conflate certain concepts
that unfortunately share very common labels (quick &ndash; what&rsquo;s the difference
between properties and parameters, and give me the lowdown on MCollective
agents versus Puppet agents!).</p>

<p>And then we have &lsquo;environments&rsquo; + Hiera + R10k.</p>

<h3>Puppet &lsquo;environments&rsquo;</h3>

<p>Puppet has the concept of &lsquo;environments&rsquo;, which, to me, exist to provide a
means of compiling a catalog using different paths to Puppet modules on the
Puppet master. Using a Puppet environment is the same as saying &ldquo;I made some
changes to my tomcat class, but I don&rsquo;t want to push it DIRECTLY to my production
machines yet because I don&rsquo;t drink Dos Equis. It would be great if I could stick
this code somewhere and have a couple of my nodes test how it works before
merging it in!&rdquo;</p>

<p>Puppet environments suffer some &lsquo;seepage&rsquo; issues,
<a href="http://projects.puppetlabs.com/issues/12173">which you can read about here,</a> but do a reasonable job of quickly
testing out changes you&rsquo;ve made to the Puppet DSL (as opposed to custom
plugins, as detailed in the bug). Puppet environments work well when you
need a pipeline for testing your Puppet code (again, when you&rsquo;re refactoring
or adding new functionality), and using them for that purpose is great.</p>

<h3>Internal &lsquo;environments&rsquo;</h3>

<p>What I consider &lsquo;internal environments&rsquo; have a couple of names &ndash; sometimes
they&rsquo;re referred to as application or deployment gateways, sometimes as &lsquo;tiers&rsquo;, but
in general they&rsquo;re long-term groupings that machines/nodes are attached to
(usually for the purpose of phased-out application deployments). They
frequently have names such as &lsquo;dev&rsquo;, &lsquo;test&rsquo;, &lsquo;prod&rsquo;, &lsquo;qa&rsquo;, &lsquo;uat&rsquo;, and the
like.</p>

<p>For the purpose of distinguishing them from Puppet environments, I&rsquo;m going to
refer to them as &lsquo;application tiers&rsquo; or just &lsquo;tiers&rsquo; because, fuck it, it&rsquo;s a
word.</p>

<h3>Making both of them work</h3>

<p>The problems with having Puppet environments and application tiers are:</p>

<ul>
<li>Puppet environments are usually assigned to a node for short periods of time,
while application tiers are usually assigned to a node for the life of the node.</li>
<li>Application tiers usually need different bits of data (i.e. NTP server
addresses, versions of packages, etc), while Puppet environments usually
use/involve differences to the Puppet DSL.</li>
<li>Similarly to the first point, the goal of Puppet environments is to eventually
merge code differences into the main production Puppet environment. Application
tiers, however, may always have differences about them and never become unified.</li>
</ul>


<p>You can see where this would be problematic &ndash; especially when you might want to
do things like use different Hiera values between different application tiers,
but you want to TEST out those values before applying them to all nodes in an
application tier. If you previously didn&rsquo;t have a way to separate Puppet
environments from application tiers, and you used R10k to generate Puppet
environments, you would have things like long-term branches in your repositories
that would make it difficult/annoying to manage.</p>

<p><strong>NOTE: This is all assuming you&rsquo;re managing component modules, Hiera data,
and Puppet environments using R10k.</strong></p>

<p>The first step in making both monikers work together is to have two separate
variables in Puppet &ndash; namely <code>$environment</code> for Puppet environments, and
something ELSE (say, <code>$tier</code>) for the application tier. The &ldquo;something else&rdquo; is
going to depend on how your workflow works. For example, do you have something
centrally that can correlate nodes to the tier in which they belong? If so, you
can write a custom fact that will query that service. If you don&rsquo;t have this
magical service, you can always just attach an application tier to a node in
your classification service (i.e. the Puppet Enterprise Console or Foreman).
Failing both of those, <a href="http://docs.puppetlabs.com/guides/custom_facts.html#external-facts">you can look to external facts.</a> External Fact
support was introduced into Facter 1.7 (but Puppet Enterprise has supported
them through the standard lib for quite awhile). External facts give you the
ability to create a text file inside the facts.d directory in the format of:</p>

<p><code>
tier=qa
location=portland
</code></p>

<p>Facter will read this text file and store the values as facts for a Puppet run,
so <code>$tier</code> will be <code>qa</code> and <code>$location</code> will be <code>portland</code>. This is handy for
when you have arbitrary information that can&rsquo;t be easily discovered by the
node, but DOES need to be assigned for the node on a reasonably consistent
basis.  Usually these files are created during the provisioning process, but
can also be managed by Puppet.  At any rate, having <code>$environment</code> and <code>$tier</code>
available allow us to start to make decisions based on the values.</p>

<h3>Branch with $environment, Hiera with $tier</h3>

<p>Like we said above, Puppet environments are frequently short-term assignments,
while application tiers are usually long-term residencies. Relating those back
to the R10k workflow: branches to the main puppet repo (containing the
<code>Puppetfile</code>) are usually short-lived, while data in Hiera is usually
longer-lived. It would then make sense that the name of the branches to the
main puppet repo would resolve to being <code>$environment</code> (and thus the Puppet
environment name), and <code>$tier</code> (and thus the application tier) would be used
in the Hiera hierarchy for lookups of values that would remain different across
application tiers (like package versions, credentials, and etc&hellip;).</p>

<p>Wins:</p>

<ul>
<li>Puppet environment names (like repository branch names) become relatively
meaningless and are the &ldquo;means&rdquo; to the end of getting Puppet code merged into
the PUPPET CODE&rsquo;s production branch (i.e. code that has been tested to work
across all application tiers)</li>
<li>Puppet environments become short lived and thus have less opportunity to
deviate from the main production codebase</li>
<li>Differences across application tiers are locked in one place (Hiera)</li>
<li>Differences to Puppet DSL code (i.e. in Manifests) can be pushed up to the
profile level, and you have a fact (<code>$tier</code>) to catch those differences.</li>
</ul>


<p>The ultimate reason why I&rsquo;m writing about this is because I&rsquo;ve seen people try
to incorporate both the Puppet environment and application tier into both the
environment name and/or the Hiera hierarchy. Many times, they run into all
kinds of unscalable issues (large hierarchies, many Puppet environments,
confusing testing paths to &lsquo;production&rsquo;). I tend to prefer this workflow
choice, but, like everything I write about, take it and model it toward what
works for you (because what works now may not work 6 months from now).</p>

<h2>Thoughts?</h2>

<p>Like I said before, I tend to discover new corner cases that change my mind
on things like this, so it&rsquo;s quite possible that this theory isn&rsquo;t the most
solid in the world. It HAS helped out some customers to clean up their code
and make for a cleaner pipeline, though, and that&rsquo;s always a good thing. Feel
free to comment below &ndash; I look forward to making the process better for all!</p>
]]></content>
  </entry>
  
</feed>
