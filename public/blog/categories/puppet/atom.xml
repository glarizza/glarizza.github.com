<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: puppet | Shit Gary Says]]></title>
  <link href="http://garylarizza.com/blog/categories/puppet/atom.xml" rel="self"/>
  <link href="http://garylarizza.com/"/>
  <updated>2013-11-30T15:21:36-08:00</updated>
  <id>http://garylarizza.com/</id>
  <author>
    <name><![CDATA[Gary larizza]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Who abstracted my Ruby?]]></title>
    <link href="http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/"/>
    <updated>2013-11-26T16:01:00-08:00</updated>
    <id>http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2</id>
    <content type="html"><![CDATA[<p>Previously, on Lost, I said a lot of words about Puppet Types;
<a href="http://garylarizza.com/blog/2013/11/25/fun-with-providers/">you should totally check it out.</a>
In this second installment, you&rsquo;re going to find out how to actually throw
pure Ruby at Puppet in a way that makes you feel accomplished. And useful. And elitist.
Well, possibly just elitist. Either way, read on &ndash; there&rsquo;s much thought-leadership to be done&hellip;</p>

<p>In the last post, we learned that Types will essentially dictate the attributes
that you&rsquo;ll be passing in your resource declaration using the DSL. In the
simplest and crudest explanation I could muster, types model how your
declaration will look in the manifest. Providers are where the actual
IMPLEMENTATION happens. If you&rsquo;ve ever wondered how this:</p>

<p>{% codeblock lang:puppet %}
package { &lsquo;httpd&rsquo;:
  ensure => installed,
}
{% endcodeblock %}</p>

<p>eventually gets turned into this:</p>

<p>{% codeblock lang:bash %}
yum install -e 0 -d 0 -y httpd
{% endcodeblock %}</p>

<p>your answer would be &ldquo;It&rsquo;s in the provider file&rdquo;.</p>

<h2>Dirty black magic</h2>

<p>I&rsquo;ve seen people do the craziest shit imaginable in the Puppet DSL simply because
they&rsquo;re:</p>

<ul>
<li>Unsure how types and providers work</li>
<li>Afraid of Ruby</li>
<li>Confused by error messages</li>
<li>Afraid to ask for help</li>
</ul>


<p>Sometimes you have a problem that can only be solved by interacting with data
that&rsquo;s returned by a binary (using some binary to get a value, and then using
that binary to set a value, and so on&hellip;). I see people writing defined resource
types with a SHIT TON of <code>exec</code> statements and conditional logic to model this
data when a type and provider would not only BETTER model the problem but would
also be shareable and re-useable by other folk. The issue is that while the DSL
is REALLY easy to get started with, types and providers still feel like dirty
black magic.</p>

<p>The reason is because they&rsquo;re dirty black magic.</p>

<p>Hopefully, I can help get you over the hump and onto a working implementation. Let&rsquo;s
take a problem I had last week:</p>

<h2>Do this if that, and then be done</h2>

<p>I was working with a group who wanted to set a list of domains that would
bypass their web proxy for a specific network interface on an OS X workstation.
It sounds so simple, because it was. Due to the amount of time I had on-site,
I wrote a class with some nasty <code>exec</code> statements, a couple of facts, and some
conditional logic because that&rsquo;s what you do when you&rsquo;re in a hurry&hellip;but it
doesn&rsquo;t make it right. When I left, I hacked up a type and provider, and it&rsquo;s
a GREAT example because you probably have a similar problem.  Let&rsquo;s look at the
information we have:</p>

<p>The list of network interfaces:</p>

<p>{% codeblock lang:bash %}
└▷ networksetup -listallnetworkservices
An asterisk (*) denotes that a network service is disabled.
Bluetooth DUN
Display Ethernet
Ethernet
FireWire
Wi-Fi
iPhone USB
Bluetooth PAN
{% endcodeblock %}</p>

<p>Getting the list of bypass domains for an interface:</p>

<p>{% codeblock lang:bash %}
└▷ networksetup -getproxybypassdomains Ethernet
www.garylarizza.com
*.corp.net
10.13.1.3/24
{% endcodeblock %}</p>

<p>The message displayed when no domains are set for an interface:</p>

<p>{% codeblock lang:bash %}
└▷ networksetup -getproxybypassdomains FireWire
There aren&rsquo;t any bypass domains set on FireWire.
{% endcodeblock %}</p>

<p>Setting the list of bypass domains for an interface:</p>

<p>{% codeblock lang:bash %}
└▷ networksetup -setproxybypassdomains Ethernet &lsquo;*.corp.net&rsquo; &lsquo;10.13.1.3/24&rsquo; &lsquo;www.garylarizza.com&rsquo;
{% endcodeblock %}</p>

<p>Perfect &ndash; all of that is done with a single binary, and it&rsquo;s pretty straightforward. Let&rsquo;s look at the type I ended up creating for this problem:</p>

<p>{% codeblock lib/puppet/type/mac_proxy_bypassdomains.rb lang:ruby %}
Puppet::Type.newtype(:mac_proxy_bypassdomains) do
  desc &ldquo;Puppet type that models bypass domains for a network interface on OS X&rdquo;</p>

<p>  ensurable</p>

<p>  newparam(:name, :namevar => true) do</p>

<pre><code>desc "Interface name - currently must be 'friendly' name (e.g. Ethernet)"
</code></pre>

<p>  end</p>

<p>  newproperty(:domains, :array_matching => :all) do</p>

<pre><code>desc "Domains which should bypass the proxy"
def insync?(is)
  is.sort == should.sort
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>The type uses a namevar parameter called &lsquo;name&rsquo;, which is the name of the network interface.
This means that we can set one list of bypass domains for every network interface.
There&rsquo;s a single property, &lsquo;domains&rsquo; that accepts an array of domains that should bypass
the proxy for the network interface. I&rsquo;ve overridden the <code>insync?</code> method for the domains
property to sort the array values on both ends &ndash; this means that the ORDER of the domains
doesn&rsquo;t matter, I only care that the domains specified exist on the system. Finally, the
type is ensurable (which means that we can create a list of domains and remove/destroy
the list of domains for a network interface).</p>

<h2>Setup the provider</h2>

<p>Okay, so we&rsquo;ve defined the problem, seen how to interact with the system to get us the
data that we need, setup a type to model the data, and now the last thing left to do
is to wire up the provider to make the binary calls we need and return the data we
want.</p>

<h3>Typos are not your friend.</h3>

<p>The first thing you will encounter is &ldquo;Puppet&rsquo;s predictable naming pattern&rdquo;
that is used by the Puppet autoloader. Typos are not fun, and omitting a single
letter in either the filename or the provider name will render your provider
(emotionally) unavailable to Puppet. Our type is called &lsquo;mac_proxy_bypassdomains&rsquo;,
as types are generally named along the lines of &lsquo;what does this data model?&rsquo; The
provider name is generally the name of the underlying technology that&rsquo;s doing
the modeling. For the package type, the providers are named after the package
management systems (e.g. yum, apt, pacman, zypper, pip), for the file type, the
providers are loosely named for the operatingsystem kernel type on which files
are to be created (e.g. windows, posix). In our example, I simply chose to name
the provider &lsquo;ruby&rsquo; because, as a Puppet Labs employee, <strong>I TOO</strong> suck at naming
things.</p>

<p>Here&rsquo;s a tree of my module to understand how the type and provider files are
to be laid out:</p>

<p>{% codeblock Module tree lang:bash %}
├── Modulefile
├── README.markdown
└── lib
    └── puppet
        ├── provider
        │   ├── mac_proxy_bypassdomains
        │   │   └── ruby.rb
        └── type
            └── mac_proxy_bypassdomains.rb
{% endcodeblock %}</p>

<p>As you can see from above, the name of both the type and provider must <strong>EXACTLY</strong>
match the filename of their corresponding files. Also, the provider file lives
in a directory named after the type. There are MANY things that can be typoed here
(filenames, foldernames, type/provider names in their files), so be absolutely sure
that you&rsquo;ve named your files correctly.</p>

<p>The reason for all this naming bullshit is because of the way Puppet syncs down
plugin files (coincidentally, with a <a href="http://docs.puppetlabs.com/guides/plugins_in_modules.html">process known as Pluginsync)</a>.
Everything in the <code>lib</code> directory in a Puppet module is going to get synced down
to your nodes inside <a href="http://docs.puppetlabs.com/references/latest/configuration.html#vardir">the <code>vardir</code> directory</a> on
the node itself. The <code>vardir</code> is a known library path to Puppet, and all files
in the <code>vardir</code> are treated as if they had lived in Puppet&rsquo;s source code (in
the same relative paths).  Because the Puppet source code has all type files in
the <code>lib/puppet/type</code> directory, all <strong>CUSTOM</strong> types must go in the module&rsquo;s
<code>lib/puppet/type</code> directory for confirmity.  This is repeated for <strong>EVERY</strong>
custom Puppet/Facter plugin (including custom facts, custom functions, and
etc&hellip;).</p>

<h3>More scaffolding</h3>

<p>Let&rsquo;s layout the shell of our provider, first, to ensure that we haven&rsquo;t typoed
anything. Here&rsquo;s the provider declaration:</p>

<p>{% codeblock lib/puppet/type/mac_proxy_bypassdomains/ruby.rb lang:ruby %}
Puppet::Type.type(:mac_proxy_bypassdomains).provide(:ruby) do
  # Provider work goes here
end
{% endcodeblock %}</p>

<p>Note that the name of the type and the name of the provider are symbolized (i.e.
they&rsquo;re prepended with a colon). Like I mentioned above, they must be spelled
EXACT or Puppet will complain very loudly. You may see variants on that
declaration line because there are multiple ways in Ruby to extend a class
object. The method I&rsquo;ve listed above is the &lsquo;generally accepted best-practice&rsquo;, which
is to say it&rsquo;s the way we&rsquo;re doing it this month.</p>

<p>Congrats! You have THE SHELL of a provider that has yet to do a single goddamn thing!
Technically, you&rsquo;re further than about 90% of other Puppet users at this point! Let&rsquo;s
go the additional 20% (since we&rsquo;re basing this on a mangement metric of 110%) by
wiring up the methods and making the damn thing work!</p>

<h3>Are you (en)sure about this?</h3>

<p>We&rsquo;ve explained before that a type is &lsquo;ensurable&rsquo; when you can check for its existance
on a system, create it when it doesn&rsquo;t exist (and it SHOULD exist), and destroy it when
it does exist (and it SHOULDN&rsquo;T exist). The bare minimum amount of methods necessary
to make a type ensurable is three, and they&rsquo;re called <code>exists?</code>, <code>create</code>, and <code>destroy</code>.</p>

<h3>Method: <code>exists?</code></h3>

<p>The <code>exists?</code> method is a predicate method &ndash; that means it should either return
the boolean <code>true</code> or <code>false</code> value based on whether the bypass domain list
exists. Puppet will always call the <code>exists?</code> provider method to determine if
that &lsquo;thing&rsquo; (in this case, &lsquo;thing&rsquo; means &lsquo;a list of domains to bypass for a
specific network interface&rsquo;) exists before calling any other methods. How do we
know if this thing exists? Like I showed before, you need to run the
<code>networksetup -getproxybypassdomains</code> command and pass the interface name.  If
it returns &lsquo;There aren&rsquo;t any bypass domains set on (interface name)&rsquo;, then the
list doesn&rsquo;t exist. Let&rsquo;s do some binary execution&hellip;</p>

<h4>Calling binaries from Puppet</h4>

<p>Puppet provides some helper syntax around basic actions that most providers
perform. MOST providers are going to need to call out to an external binary
(e.g. yum, apt, etc&hellip;) at some point, and so Puppet allows you to create
your own method JUST for a system binary. The <code>commands</code> method abstracts
all the dirtyness of making a method for each system binary you want to call.
The way you use the <code>commands</code> method is like so:</p>

<p>{% codeblock lang:ruby %}
commands :networksetup => &lsquo;networksetup&rsquo;
{% endcodeblock %}</p>

<p>The <code>commands</code> method accepts a hash whose key must be a symbolized name. The
CONVENTION is to use a symbolized name that matches the binary name, but it&rsquo;s
not REQUIRED to do so. The value for that symbolized key MUST be the binary
name. Note that I&rsquo;ve not passed a full path to the binary. Why? Well, Puppet
will automatically do a path lookup for that binary and store its full path
for use when the binary is invoked. We don&rsquo;t REQUIRE you to pass the full
path because sometimes the same binary exists in different locations for
different operatingsystems. Instead of creating a provider for each OS you
manage with Puppet, we abstract away the path stuff. You <strong>CAN</strong> still
pass a full path as a value, but if you elect to do that an the binary doesn&rsquo;t
exist at that path, Puppet will disqualify the provider and you&rsquo;ll be quite
upset.</p>

<p>In the event that Puppet <strong>CANNOT</strong> find this binary, it will disqualify the
entire provider, and you&rsquo;ll get a message saying as much in the debug output
of your Puppet run. Because of that, the <code>commands</code> method is a good way to
confine your provider to a specific system or class of system.</p>

<p>When the <code>commands</code> method is successfully invoked, you will get a new provider
method named after the <strong>SYMBOLIZED</strong> key, and not necessarily the binary
name (unless you made them the same). After the above command is evaluated,
Puppet will now have a <code>networksetup()</code> method in our provider. The argument
to the <code>networksetup</code> method should be an array of arguments that are passed
to the binary. It&rsquo;s c-style, so each element is going to be individually
quoted. You can run into issues here if you pass values containing quotes
as part of your argument array. Read that again &ndash; quoting your values is
totally acceptable (e.g. [&lsquo;foo&rsquo;, &lsquo;bar&rsquo;]), but passing a value that contains
quotes can potentially cause problems (e.g. [&ldquo;&lsquo;foo&rsquo;&rdquo;, &ldquo;&lsquo;bar&rsquo;&rdquo;]).</p>

<p>You&rsquo;re probably thinking &ldquo;Why the hell would I go through this trouble when
I can use the <code>%x{}</code> syntax in ruby to execute a shell command?!&rdquo; And to that
I would say &ldquo;Quit yelling at me&rdquo; and also &ldquo;Because: testing.&rdquo; When you write
spec tests for your provider (which will be covered in a later blog post, since
it&rsquo;s its OWN path of WTF), you&rsquo;re going to need to mock out calls to the system
during your tests (i.e. sometimes you may be running the tests on a system that
doesn&rsquo;t have the binary you&rsquo;re meant to be calling in your provider. You don&rsquo;t
want the tests to fail due to the absence of a binary file). The <code>%x{}</code>
construct in Ruby is hard to mock out, but a method of our provider is a relatively
easy thing to mock out. Also &ndash; see the path problem above. We don&rsquo;t STOP you
from doing <code>%x{}</code> in your code (it will still totally work), but we give you
a couple of good reasons to NOT do it.</p>

<h4>Objects are a provider&rsquo;s best friend</h4>

<p>Within your provider, you&rsquo;re going to be doing lots of system calls and data
manipulation. Often we&rsquo;re asked whether you do that ugliness inside the main
methods (i.e. inside the <code>exists?</code> method directly), or if you create a
helper method for some of this data manipulation. The answer I usually give
is that you should probably create a helper method if:</p>

<ul>
<li>The code is going to be called more than once</li>
<li>The code does something that would be tricky to test (like reading from a file)</li>
<li>Complexity would be reduced by creating a helper method</li>
</ul>


<p>The act of getting a list of domains for a specific interface is definitely
going to be utilized in more than one place in our provider (we&rsquo;ll use it
in the <code>exists?</code> method as well as in a &lsquo;getter&rsquo; method for the <code>domains</code>
property). Also, you could argue that it might be tricky to test since it&rsquo;s
going to be a binary call that&rsquo;s going to return some data. Because of this,
let&rsquo;s create a helper method that returns a list of domains for a specific
interface:</p>

<p>{% codeblock lang:ruby %}
def get_proxy_bypass_domains(int)
  begin</p>

<pre><code>output = networksetup(['-getproxybypassdomains', int])
</code></pre>

<p>  rescue Puppet::ExecutionFailure => e</p>

<pre><code>Puppet.debug("#get_proxy_bypass_domains had an error -&gt; #{e.inspect}")
return nil
</code></pre>

<p>  end
  domains = output.split(&ldquo;\n&rdquo;).sort
  return nil if domains.first =~ /There aren\&rsquo;t any bypass domains set/
  domains
end
{% endcodeblock %}</p>

<p>Ruby convention is to use underscores (i.e. versus camelCase or hyphens) in
method names. You want to give your methods very descriptive names based on
what it is that they DO. In this case, <code>get_proxy_bypass_domains</code> seems
adequately descriptive. Also, you should err on the side of readability when
you&rsquo;re writing code. You can get pretty creative with Ruby metaprogramming,
but that can quickly become hard to follow (and then you&rsquo;re just a dick).
Finally, error-handling is a good thing. If you&rsquo;re going to do any error-handling,
though, be very specific about the errors you catch/rescue. When you have a rescue
block, make sure you catch a specific exception class (in the case above, we&rsquo;re
catching a Puppet::ExecutionFailure &ndash; which means the binary is returning a
non-zero exit code).</p>

<p>The code above will return an array containing all the domains, or it will
return <code>nil</code> if domains aren&rsquo;t found or the <code>networksetup</code> binary had an issue.</p>

<p>Using the helper method above, here&rsquo;s what the final <code>exists?</code> method looks like:</p>

<p>{% codeblock lang:ruby %}
def exists?
  get_proxy_bypass_domains(resource[:name]) != nil
end
{% endcodeblock %}</p>

<p>All provider methods have the ability to access the &lsquo;should&rsquo; values for the resource
(and by that I mean the values that are set in the Puppet maniest on the Puppet master
server, or locally if you&rsquo;re using <code>puppet apply</code>). Those values reside in the <code>resource</code>
method that responds with a hash. In the code above, <code>resource[:name]</code> will return the
network interface name (e.g. Ethernet, FireWire, etc&hellip;) that was specified in the
Puppet manifest. The exists method will return true of a list of domains exists for
an interface, or it will return false if a list of domains does not exist (i.e.
<code>get_proxy_bypass_domains</code> returns <code>nil</code>).</p>

<h3>Method: <code>create</code></h3>

<p>The <code>create</code> method is called when <code>exists?</code> returns false and a resource has an
<code>ensure</code> value set to <code>present</code>. Because of this, you don&rsquo;t need to call the <code>exists?</code>
method explicitly in <code>create</code> &ndash; it&rsquo;s already been evaluated. Remember from above that
the <code>-setproxybypassdomains</code> argument to the <code>networksetup</code> binary will set a domain
list, so the <code>create</code> method is going to be very short-and-sweet:</p>

<p>{% codeblock lang:ruby %}
def create
  networksetup([&lsquo;-setproxybypassdomains&rsquo;, resource[:name], resource[:domains]])
end
{% endcodeblock %}</p>

<p>In the end, the <code>create</code> method will call the <code>networksetup</code> binary with the <code>-setproxybypassdomains</code>
argument, pass the interface name (from <code>resource[:name]</code>) and pass an array of domain values (which
comes from <code>resource[:domains]</code>). That&rsquo;s it; it&rsquo;s done!</p>

<h3>Method: <code>destroy</code></h3>

<p>The <code>destroy</code> method is easier than the <code>create</code> method:</p>

<p>{% codeblock lang:ruby %}
def destroy
  networksetup([&lsquo;-setproxybypassdomains&rsquo;, nil])
end
{% endcodeblock %}</p>

<p>Here, we&rsquo;re calling <code>networksetup</code> with the <code>-setproxybypassdomains</code> argument
and passing nothing else. This will initialize the list and set it to be empty.</p>

<h2>Synchronizing properties</h2>

<h3>Getter method: <code>domains</code></h3>

<p>At this point our type is ensurable, which means we can create and destroy resources.
What we CAN&rsquo;T do, however, is change the value of any properties that are out-of-sync. A
property is out-of-sync when the value discovered by Puppet on the node differs from the
value in the catalog (i.e. set by the Puppet manifest using the DSL on the Puppet master).
Just like <code>exists?</code> is called to determine if a resource exists, Puppet needs a way to
get the current value for a property on a node. The method that gets this value is
called the &lsquo;getter method&rsquo; for a property, and its name must match the name of the
property. Because we have a property called <code>domains</code>, the provider must have a <code>domains</code>
method that returns a value (in this case, an array of domains to be bypassed by the
proxy). We&rsquo;ve already written a helper method that does this work for us, so the
<code>domains</code> getter method is pretty easy:</p>

<p>{% codeblock lang:ruby %}
def domains
  get_proxy_bypass_domains(resource[:name])
end
{% endcodeblock %}</p>

<p>Tada! Just call the helper method and pass the interface name. Boom &ndash; instant array
of values. The getter method will return the &lsquo;is&rsquo; value, because that&rsquo;s what the value
<strong>IS</strong> (currently on the node). Get it? Anyone? The <strong>IS</strong> value is the other side of
the coin to the &lsquo;should&rsquo; value (that comes from the Puppet manifest) because that&rsquo;s
what the value <strong>SHOULD</strong> be set on the node.</p>

<h3>Setter method: <code>domains=</code></h3>

<p>If the getter method (e.g. <code>domains</code>) returns a value that doesn&rsquo;t match the value
in the catalog, then Puppet changes the value on the node and sets it to the value
in the catalog. It does this by calling the &lsquo;setter&rsquo; method for the property, which
is the name of the property and the equals ( = ) sign. In this case, the setter
method for the <code>domains</code> property must be called <code>domains=</code>.  It looks like this:</p>

<p>{% codeblock lang:ruby %}
def domains=(value)
  networksetup([&lsquo;-setproxybypassdomains&rsquo;, resource[:name], value])
end
{% endcodeblock %}</p>

<p>Setter methods are always passed a single argument &ndash; the &lsquo;should&rsquo; value of the property.
In our example, we&rsquo;re calling the <code>networksetup</code> binary with the <code>-setproxybypassdomains</code>
argument, passing the name of the interface, and then passing the &lsquo;should&rsquo; value &ndash; or
the array of domains. It&rsquo;s easy, it&rsquo;s one line, and I love it when a plan comes together</p>

<h2>Putting the whole damn thing together</h2>

<p>I&rsquo;ve broken down the provider line by line, but here&rsquo;s the entire file:</p>

<p>{% codeblock lib/puppet/provider/mac_proxy_bypassdomains/ruby.rb lang:ruby %}
Puppet::Type.type(:mac_proxy_bypassdomains).provide(:ruby) do
  commands :networksetup => &lsquo;networksetup&rsquo;</p>

<p>  def get_proxy_bypass_domains(int)</p>

<pre><code>begin
  output = networksetup(['-getproxybypassdomains', int])
rescue Puppet::ExecutionFailure =&gt; e
  Puppet.debug("#get_proxy_bypass_domains had an error -&gt; #{e.inspect}")
  return nil
end
domains = output.split("\n").sort
return nil if domains.first =~ /There aren\'t any bypass domains set/
domains
</code></pre>

<p>  end</p>

<p>  def exists?</p>

<pre><code>get_proxy_bypass_domains(resource[:name]) != nil
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>networksetup(['-setproxybypassdomains', nil])
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>networksetup(['-setproxybypassdomains', resource[:name], resource[:domains]])
</code></pre>

<p>  end</p>

<p>  def domains</p>

<pre><code>get_proxy_bypass_domains(resource[:name])
</code></pre>

<p>  end</p>

<p>  def domains=(value)</p>

<pre><code>networksetup(['-setproxybypassdomains', resource[:name], value])
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h2>Testing the type/provider</h2>

<p>And that&rsquo;s it, we&rsquo;re done!  The last thing to do is to test it out.  You can
test out your provider in one of two ways: the first is to add the module to
the modulepath of your Puppet master and include it that way, or test it
locally by setting the <code>$RUBYLIB</code> environmental variable to point to the <code>lib</code>
directory of your module (which is the more preferred method since it won&rsquo;t
serve it out to all of your nodes without it being tested). Because this module
is on my system at <code>/users/glarizza/src/puppet-mac_proxy</code>, here&rsquo;s how my
<code>$RUBYLIB</code> is set:</p>

<p>{% codeblock lang:bash %}
export RUBYLIB=/users/glarizza/src/puppet-mac_proxy/lib
{% endcodeblock %}</p>

<p>Next, we need to create a resource declaration to try and set a couple of
bypass domains. I&rsquo;ll create a <code>tests</code> directory and simple test file in
<code>tests/mac_proxy_bypassdomains.pp</code>:</p>

<p>{% codeblock tests/mac_proxy_bypassdomains.pp lang:puppet %}
mac_proxy_bypassdomains { &lsquo;Ethernet&rsquo;:
  ensure  => &lsquo;present&rsquo;,
  domains => [&lsquo;www.garylarizza.com&rsquo;,&lsquo;*.puppetlabs.com&rsquo;,&lsquo;10.13.1.3/24&rsquo;],
}
{% endcodeblock %}</p>

<p>Finally, let&rsquo;s run Puppet and test it out:</p>

<p>{% codeblock %}
└▷ puppet apply ~/src/puppet-mac_proxy/tests/mac_proxy_bypassdomains.pp
Notice: Compiled catalog for satori.local in environment production in 0.06 seconds
Notice: /Stage[main]//Mac_proxy_bypassdomains[Ethernet]/domains: domains changed [] to &lsquo;www.garylarizza.com *.puppetlabs.com 10.13.1.3/24&rsquo;
Notice: Finished catalog run in 3.47 seconds
{% endcodeblock %}</p>

<p><strong>NOTE:</strong> If you run this as a local user, you will be prompted by OS X to
enter an administrative password for a change.  Since Puppet will ultimately be
run as root on OS X when we&rsquo;re NOT testing out code, this shouldn&rsquo;t be required
during a normal Puppet run. To test this out (i.e. that you don&rsquo;t always have to
enter an admin password in a pop-up window), you&rsquo;ll need to <code>sudo -s</code> to
change to root, set the <code>$RUBYLIB</code> as the root user, and then run Puppet again.</p>

<p>And that&rsquo;s it &ndash; looks like our code worked! To check and make sure it will notice a
change, open System Preferences, then the Network pane, click on the Ethernet
interface, then the Advanced button, then the Proxies tab, and finally note the
&lsquo;Bypass proxy settings&hellip;&rsquo; text box at the bottom of the screen (now do you see
why we automate this shit?!). Make a change to the entries in there and run
Puppet again &ndash; it should correct it for you</p>

<h2>Wait&hellip;so that was it?  Really?  We&rsquo;re done?</h2>

<p>Yeah, that was a whole type and provider. Granted, it has only one property and it&rsquo;s
not too complicated, but that&rsquo;s the point. We&rsquo;ve still got some latent bugs (the
network interface passed must be capitalized exactly like OS X expects it, we could
do some better error handling, etc&hellip;), and the type doesn&rsquo;t work with <code>puppet resource</code>
(yet), but we&rsquo;ll handle all of these things in the next blog post (or two&hellip;or three).</p>

<p>Until then, take this time to crack open a type and a provider for something that&rsquo;s
been pissing you off and FIX it!  Better yet, push it up to Github, tweet about it,
and post it up <a href="http://forge.puppetlabs.com">on The Forge</a> so the rest of the
community can use it!</p>

<p>Like always, feel free to comment, tweet me (@glarizza), email me (gary <strong>AT</strong> puppetlabs <strong>DOT</strong> com),
or use the social media platform of choice to get a hold of me (Snapchats may or may not
get a response. Maybe.)  Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun with Puppet Providers - Part 1 of Whatever]]></title>
    <link href="http://garylarizza.com/blog/2013/11/25/fun-with-providers/"/>
    <updated>2013-11-25T20:47:00-08:00</updated>
    <id>http://garylarizza.com/blog/2013/11/25/fun-with-providers</id>
    <content type="html"><![CDATA[<p>I don&rsquo;t know why I write blog posts &ndash; everybody in open-source software knows
that the code <em>IS</em> the documentation. If you&rsquo;ve ever tried to write a Puppet
type/provider, you know this fact better than ANYONE. To this day, when someone
asks me for the definitive source on this activity I usually refer them first
to <a href="http://www.amazon.com/Puppet-Types-Providers-Dan-Bode/dp/1449339328">Nan Liu and Dan Bode&rsquo;s awesome Types and Providers
book</a>
(which REALLY is a fair bit of quality information), and THEN to the source
code for Puppet. Everything else falls in-between those sources (sadly).</p>

<p>As someone who truly came from knowing absolute fuckall about Ruby and only
marginally more than that about Puppet, I&rsquo;ve walked through the valley of the
shadow of self.instances and have survived to tell the tale. That&rsquo;s what this
post is about &ndash; hopefully some GOOD information if you want to start writing
your own Puppet type and provider. I also wrote this because this knowledge
has been passed down from Puppet employee to Puppet employee, and I wanted
to break the priesthood being held on type and provider magic. If you don&rsquo;t
hear from me after tomorrow, well, then you know what happened&hellip;</p>

<h2>Because 20 execs in a defined type&hellip;</h2>

<p>What would drive someone to write a custom type and provider for Puppet anyhow?
Afterall, you can do ANYTHING IMAGINABLE in the Puppet DSL*! After drawing
back my sarcasm a bit, let me explain where the Puppet DSL tends to fall over
and the idea of a custom type and provider starts becoming more than just an
incredibly vivid dream:</p>

<ul>
<li>You have more than a couple of exec statements in a single class/defined type that have multiple conditional
properties like &lsquo;onlyif&rsquo; and/or &lsquo;unless&rsquo;.</li>
<li>You need to use pure Ruby to manipulate data and parse it through a system binary</li>
<li>Your defined type has more conditional logic than your pre-nuptual agreement</li>
<li>Any combination of similar arguments related to the above</li>
</ul>


<p>If the above sounds familiar to you, then you&rsquo;re probably ready to build your own custom Puppet type and provider.
Do note that custom types and providers are written in Ruby and not the Puppet DSL. This can initially feel
very scary, but get over it (there are much scarier things coming).</p>

<p><em>* Just because you can doesn&rsquo;t mean you don&rsquo;t, in fact, suck.</em></p>

<h2>I&rsquo;m not your Type</h2>

<p>This blog post is going to focus on types and type-interaction, while later
posts will focus on providers and ultimately dirty provider tricks to win
friends and influence others.  Type and provider interaction can be totally
daunting for newcomers, let ALONE just naming files correctly due to Puppet&rsquo;s
predictable (note: anytime I write the word &ldquo;predictable&rdquo;, just substitute the
phrase &ldquo;annoying pain in the ass&rdquo;) naming pattern.  Let&rsquo;s break it down a bit
for you &ndash; somebody que Dre&hellip;</p>

<p>(NOTE: I&rsquo;m going to ASSUME you understand the fundamentals of a Puppet run already. If you&rsquo;re pretty hazy
on that concept, checkout <a href="http://docs.puppetlabs.com">docs.puppetlabs.com</a> for more information)</p>

<h2>Types are concerned about your looks</h2>

<p>The type file defines all the <em>properties</em> and <em>parameters</em> that can be used by your new custom resource.
Think of the type file like the opening stanza to a new Puppet class &ndash; we&rsquo;re describing all the tweakable
knobs and buttons to the new thing we&rsquo;re creating. The type file also gives you some added validation
abilities, which is very handy.</p>

<p>It&rsquo;s important to understand that there is a BIG difference between a &lsquo;property&rsquo; and a &lsquo;parameter&rsquo; with regard
to a type (even though they&rsquo;re both assigned values identically in a resource declaration).  Think of it this
way: a property is something that can be inspected and changed by Puppet, while a parameter is just helper data
that Puppet uses to do its job.  A property would be something like a file&rsquo;s mode.  You can inspect a file and
determine its mode, and you can even CHANGE a file&rsquo;s mode on disk. The file resource type also has a parameter
called &lsquo;backup&rsquo;.  Its sole job is to tell Puppet whether to backup the file to the filebucket before making
changes. This data is useful for Puppet during a run, but you can&rsquo;t inspect a file on disk and know definitively
whether Puppet is going to back it up or not (and it goes without saying that if you can&rsquo;t determine this aspect
about a file on disk just by inspecting it, than you also can&rsquo;t CHANGE this aspect about a file on disk either).
You&rsquo;ll see later where the property/parameter distinction becomes very important.</p>

<p>Recently I built a type modeling the setting of proxy data for network interfaces on OS X, so we&rsquo;ll use that as
a demonstration of a type.  It looks like the following:</p>

<p>{% codeblock lib/puppet/type/mac_web_proxy.rb lang:ruby %}
Puppet::Type.newtype(:mac_web_proxy) do
  desc &ldquo;Puppet type that models a network interface on OS X&rdquo;</p>

<p>  ensurable</p>

<p>  newparam(:name, :namevar => true) do</p>

<pre><code>desc "Interface name - currently must be 'friendly' name (e.g. Ethernet)"
munge do |value|
  value.downcase
end
def insync?(is)
  is.downcase == should.downcase
end
</code></pre>

<p>  end</p>

<p>  newproperty(:proxy_server) do</p>

<pre><code>desc "Proxy Server setting for the interface"
</code></pre>

<p>  end</p>

<p>  newparam(:authenticated_username) do</p>

<pre><code>desc "Username for proxy authentication"
</code></pre>

<p>  end</p>

<p>  newparam(:authenticated_password) do</p>

<pre><code>desc "Password for proxy authentication"
</code></pre>

<p>  end</p>

<p>  newproperty(:proxy_authenticated) do</p>

<pre><code>desc "Proxy Server setting for the interface"
newvalues(:true, :false)
</code></pre>

<p>  end</p>

<p>  newproperty(:proxy_port) do</p>

<pre><code>desc "Proxy Server setting for the interface"
newvalues(/^\d+$/)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>First note the type file&rsquo;s path in the grey titlebar of the graphic: <code>lib/puppet/type/mac_web_proxy.rb</code>
This path is relative to the module that you&rsquo;re building, and it&rsquo;s VERY important that it be named
EXACTLY this way to appease Puppet&rsquo;s predictable naming pattern.  The name of the file directly correllates
to the name of the type listed in the <code>Puppet::Type.newtype()</code> method.</p>

<p>Next, let&rsquo;s look at a sample parameter declaration &ndash; for starters, let&rsquo;s look at the &lsquo;authenticated_password&rsquo;
parameter declaration on line 24 of the above type.  The <code>newparam()</code> method is called and the lone argument
passed is the symbolized name of our parameter (i.e. it&rsquo;s prepended with a colon).  This parameter
provides the password to use when setting up an authenticated web proxy on OS X.
It&rsquo;s a parameter because as far as I know, there&rsquo;s no way for me to query the system for this password
(it&rsquo;s obfuscated in the GUI and I&rsquo;m not entirely certain where it&rsquo;s stored on-disk).
If there were a way for us to query this value from the system, then we could turn it
into a property (since we could both &lsquo;GET&rsquo; as well as &lsquo;SET&rsquo; the value). As of right
now, it exists as helper data for when I need to setup an authenticated proxy.</p>

<p>Having seen a parameter, let&rsquo;s look at the &lsquo;proxy_server&rsquo; property that&rsquo;s declared on
line 16 of the type file above. We&rsquo;re able to both query the system for this value,
as well as change/set the value by using the <code>networksetup</code> binary, so it&rsquo;s able to
be &lsquo;synchronized&rsquo; (according to Puppet). Because of this, it must be a property.</p>

<h2>Just enough validation</h2>

<p>The second major function of the type file is to provide methods to validate property
and parameter data that is being passed. There are two methods to validate this data,
and one method that allows you to massage the data into an acceptable format (which
is called &lsquo;munging&rsquo;).</p>

<h3>validate()</h3>

<p>The first method, named &lsquo;validate&rsquo;, is widely believed to be the only successfully-named
method in the entire Puppet codebase. Validate accepts a block and allows you to perform
free-form validation in any way you prefer.  For example:</p>

<p>{% codeblock lib/puppet/type/user.rb lang:ruby %}
validate do |value|
  raise ArgumentError, &ldquo;Passwords cannot include &lsquo;:&rsquo;&rdquo; if value.is_a?(String) and value.include?(&ldquo;:&rdquo;)
end
{% endcodeblock %}</p>

<p>This example, pulled straight from the Puppet codebase, will raise an error if a
password contains a colon. In this case, we&rsquo;re looking for a specific exception
and are raising errors accordingly.</p>

<h3>newvalues()</h3>

<p>The second method, named &lsquo;newvalues&rsquo;, accepts a regex that property/parameter values
need to match (if you&rsquo;re one of the 8 people in the world that speak regex fluently),
or a list of acceptable values. From the example above:</p>

<p>{% codeblock lib/puppet/type/mac_web_proxy.rb lang:ruby %}
  newproperty(:proxy_authenticated) do</p>

<pre><code>desc "Proxy Server setting for the interface"
newvalues(:true, :false)
</code></pre>

<p>  end</p>

<p>  newproperty(:proxy_port) do</p>

<pre><code>desc "Proxy Server setting for the interface"
newvalues(/^\d+$/)
</code></pre>

<p>  end
{% endcodeblock %}</p>

<h3>munge()</h3>

<p>The final method, named &lsquo;munge&rsquo; accepts a block like <code>newvalues</code> but allows you to
convert an unacceptable value into an acceptable value. Again, this is from the example above:</p>

<p>{% codeblock lib/puppet/type/mac_web_proxy.rb lang:ruby %}
munge do |value|
  value.downcase
end
{% endcodeblock %}</p>

<p>In this case, we want to ensure that the parameter value is lower case. It&rsquo;s not
necessary to throw an error, but rather it&rsquo;s acceptable to &lsquo;munge&rsquo; the value to
something that is more acceptable without alerting the user.</p>

<h2>Important type considerations</h2>

<p>You could write half a book just on how types work (and, again, check out the book
referenced above which DOES just that), but there are a couple of final considerations
that will prove helpful when developing your type.</p>

<h3>Defaulting values</h3>

<p>The <code>defaultto</code> method provides a default value should the user not provide one for
your property/parameter. It&rsquo;s a pretty simple construct, but it&rsquo;s important to
remember when you write spec tests for your type (which you ARE doing, right?) that
there will ALWAYS be values for properties/parameters that utilize <code>defaultto</code>. Here&rsquo;s a quick example:</p>

<p>{% codeblock Defaultto example lang:ruby %}
newparam(:enable_lacp) do
  defaultto :true
  newvalues(:true, :false)
end
{% endcodeblock %}</p>

<h3>Ensurable types</h3>

<p>A resource is considered &lsquo;ensurable&rsquo; when its presence can be verified (i.e. it
exists on the system), it can be created when it doesn&rsquo;t exist and it SHOULD, and
it can be destroyed when it exists and it SHOULDN&rsquo;T. The simplest way to tell
Puppet that a resource type is ensurable is to call the <code>ensurable</code> method within
the body of the type (i.e. outside of any property/parameter declarations). Doing
this will automatically create an &lsquo;ensure&rsquo; property that accepts values of &lsquo;absent&rsquo;
and &lsquo;present&rsquo; that are automatically wired to the &lsquo;exists?&rsquo;, &lsquo;create&rsquo; and &lsquo;destroy&rsquo;
methods of the provider (something I&rsquo;ll write about in the next post). Optionally,
you can choose to pass a block to the <code>ensurable</code> method and define acceptable
property values as well as the methods of the provider that are to be called. That
would look something like this:</p>

<p>{% codeblock lib/puppet/type/package.rb lang:ruby %}
ensurable do
  newvalue(:present) do</p>

<pre><code>provider.install
</code></pre>

<p>  end</p>

<p>  newvalue(:absent) do</p>

<pre><code>provider.uninstall
</code></pre>

<p>  end</p>

<p>  newvalue(:purged) do</p>

<pre><code>provider.purge
</code></pre>

<p>  end</p>

<p>  newvalue(:held) do</p>

<pre><code>provider.hold
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>This means that instead of calling the <code>create</code> method to create a new resource that
SHOULD exist (but doesn&rsquo;t), Puppet is going to call the <code>install</code> method. Conversely,
it will call the <code>uninstall</code> method to destroy a resource based on this type. The
ensure property will also accept values of &lsquo;purged&rsquo; and &lsquo;held&rsquo; which will be wired up
to the <code>purge</code> and <code>hold</code> methods respectively.</p>

<h3>Namevars are unique little snowflakes</h3>

<p>Puppet has a <a href="http://docs.puppetlabs.com/puppet/2.7/reference/lang_resources.html#namenamevar">concept known as the &lsquo;namevar&rsquo; for a resource.</a>
If you&rsquo;re hazy about the concept check out the documentation, but basically it&rsquo;s the parameter
that describes the form of uniqueness for a resource type on the system. For the package resource
type, the &lsquo;name&rsquo; parameter is the namevar because the way you tell one package from another is
its name. For the file resource, it&rsquo;s the &lsquo;path&rsquo; parameter, because you can differentiate unique
files from each other according to their path (and not necessarily their filename, since filenames
don&rsquo;t have to be unique on systems).</p>

<p>When designing a type, it&rsquo;s important to consider WHICH parameter will be the namevar (i.e. how
can you tell unique resources from one another). To make a parameter the namevar, you simply
set the <code>:namevar</code> attribute to <code>:true</code> like below:</p>

<p>{% codeblock lang:ruby %}
newparam(:name, :namevar => :true) do
  # Type declaration attributes here&hellip;
end
{% endcodeblock %}</p>

<h3>Handling array values</h3>

<p>Nearly every property/parameter value that is declared for a resource is &lsquo;stringified&rsquo;, or
cast to a string. Sometimes, however, it&rsquo;s necessary to accept an array of elements as the
value for a property/parameter. To do this, you have to explicitly tell Puppet that you&rsquo;ll
be passing an array by setting the <code>:array_matching</code> attribute to <code>:all</code> (if you don&rsquo;t set
this attribute, it defaults to <code>:first</code>, which means that if you pass an array as a value
for a property/parameter, Puppet will only accept the FIRST element in that array).</p>

<p>{% codeblock lang:ruby %}
newproperty(:domains, :array_matching => :all) do
  # Type declaration attributes here&hellip;
end
{% endcodeblock %}</p>

<p>If you set <code>:array_matching</code> to <code>:all</code>, EVERY value passed for that parameter/property will
be cast to an array (which means if you pass a value of &lsquo;foo&rsquo;, you&rsquo;ll get an array with a
single element &ndash; the string of &lsquo;foo&rsquo;).</p>

<h3>Documenting your property/parameter</h3>

<p>It&rsquo;s a best-practice to document the purpose of your property or parameter declaration, and
this can be done by passing a string to the <code>desc</code> method within the body of the property/parameter
declaration.</p>

<p>{% codeblock lang:ruby %}
newproperty(:domains, :array_matching => :all) do
  desc &ldquo;Domains which should bypass the proxy&rdquo;</p>

<h1>Type declaration attributes here&hellip;</h1>

<p>end
{% endcodeblock %}</p>

<h3>Synchronization tricks</h3>

<p>Puppet uses a method called <code>insync?</code> to determine whether a property value is synchronized (i.e.
if Puppet needs to change its value, or it&rsquo;s set appropriately). You usually have no need to change
the behavior of this method since most of the properties you create for a type will have string
values (and the <code>==</code> operator does a good job of checking string equality). For structured data
types like arrays and hashes, however, that can be a bit trickier. Arrays, for example, are
ordered construct &ndash; they have a definitive idea of what the first element and the last element
of the array are. Sometimes you WANT to ensure that values are in a very specific order, and
sometimes you don&rsquo;t necessarily care about the ORDER that values for a property are set &ndash; you
just want to make sure that all of them are set.</p>

<p>If the latter cases sounds like what you need, then you&rsquo;ll need to override the behavior of the
<code>insync?</code> method. Take a look at the below example:</p>

<p>{% codeblock lang:ruby %}
newproperty(:domains, :array_matching => :all) do
  desc &ldquo;Domains which should bypass the proxy&rdquo;
  def insync?(is)</p>

<pre><code>is.sort == should.sort
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>In this case, I&rsquo;ve overridden the <code>insync?</code> method to first sort the &lsquo;is&rsquo; value (or, the value that
was discovered by Puppet on the target node) and compare it with the sorted &lsquo;should&rsquo; value (or,
the value that was specified in the Puppet manifest when the catalog was compiled by the Puppet
master). You can do WHATEVER you want in here as long as <code>insync?</code> returns either a true or a
false value.  If <code>insync?</code> returns true, then Puppet determines that everything is in sync and
no changes are necessary, whereas if it returns false then Puppet will trigger a change.</p>

<h2>And this was the EASY part!</h2>

<p>Wow this went longer than I expected&hellip; and types are usually the &lsquo;easier&rsquo; bit
since you&rsquo;re only describing the format to be used by the Puppet admin in
manifests. There are some hacky type tricks that I&rsquo;ve not yet covered (i.e.
features, &lsquo;inheritance&rsquo;, and other meta-bullshit), but those will be saved for
a final &lsquo;dirty tips and tricks&rsquo; post.  In the next section, I&rsquo;ll touch on
providers (which is where all interaction with the system takes place), so
stay tuned for more brain-dumping-goodness&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repeatable Puppet development with Vagrant]]></title>
    <link href="http://garylarizza.com/blog/2013/02/01/repeatable-puppet-development-with-vagrant/"/>
    <updated>2013-02-01T00:00:00-08:00</updated>
    <id>http://garylarizza.com/blog/2013/02/01/repeatable-puppet-development-with-vagrant</id>
    <content type="html"><![CDATA[<p>I miss testing code in production. In smaller organizations, &lsquo;testing&rsquo; and
&lsquo;development&rsquo; can sometimes consist of making changes directly on a server,
walking to an active machine, and hoping things work. Once you were done, you
MIGHT document what changes you made, but more often than not you kept that
information in your head and referred to it later.</p>

<p>I lied &ndash; that is everything that sucks about manual configuration of machines.</p>

<p>The best way to get out of this rut is to get addicted to automating first the
menial tasks on your machines, and then work your way up from there. We STILL
have the problem, though, of doing this in production &ndash; that&rsquo;s what this post
is meant to address.</p>

<p>What we want is the ability to spin up a couple of test nodes for the purpose
of testing our automation workflow BEFORE it gets committed and applied to our
production nodes. This post details using <a href="http://www.vagrantup.com">Vagrant</a> and
<a href="http://www.puppetlabs.com">Puppet</a> to both establish a clean test environment and also test
automation changes BEFORE applying them to your production environment.</p>

<p><a href="http://www.puppetlabs.com">Puppet</a> is a Configuration Management tool that automates all the
annoying aspects of manual configuration out of your infrastructure. The bulk
of its usage is beyond the scope of THIS post, however we&rsquo;re going to be using
it as the means to describe the changes we want to make on our systems.</p>

<p><a href="http://www.vagrantup.com">Vagrant</a> is a magical project that uses minimal VM templates (boxes)
to spin up clean virtualized environments on your workstation for the purpose
of testing changes. Currently, it only supports a Virtualbox backend, but its
creator, <a href="http://twitter.com/mitchellh">Mitchell Hashimoto</a>, has <a href="http://vimeo.com/58059557">teased a preview of upcoming VMware</a>
integration that SHOULD be coming any day now. In this post, Vagrant will be
the means by which we spin up new VMs for development purposes</p>

<h2>Getting setup</h2>

<p>The only moving piece you need installed on your system is <a href="http://www.vagrantup.com">Vagrant</a>.
Fortunately, Mitchell <a href="http://downloads.vagrantup.com">provides native package installers</a> on his website for
downloading Vagrant. If you&rsquo;ve never used Vagrant before, and you AREN&rsquo;T a Ruby
developer who maintains multiple Ruby versions on your system, then you&rsquo;ll want
to opt for the native package installer since it&rsquo;s the easiest method to get
Vagrant installed (and, on Macs, Vagrant embeds its own Ruby AND Rubygems
binaries in the Package bundle&hellip;which is kind of cool).</p>

<p>IF, however, you are developing in Ruby and you use <a href="https://rvm.io/">RVM</a> or <a href="https://github.com/sstephenson/rbenv/">Rbenv</a>
to maintain multiple copies of Ruby on your system, then you&rsquo;ll want to favor
installing Vagrant via Rubygems a la:</p>

<p>{% codeblock lang:bash %}
$ gem install vagrant &mdash;no-ri &mdash;no-rdoc
{% endcodeblock %}</p>

<p>If you have no idea how to use RVM or Rbenv &ndash; stick with the <a href="http://downloads.vagrantup.com">native installers</a> :)</p>

<p>Puppet does NOT need to be on your workstation since we&rsquo;re only going to be using it on the VMs that
Vagrant spins up &ndash; so don&rsquo;t worry about Puppet yet.</p>

<h2>My kingdom for a box</h2>

<p>Vagrant uses box files as templates from which to spin up a new virtual machine
for development purposes. <a href="http://vagrantbox.es">There are sites that host boxes available for download</a>,
OR, you could use <a href="https://github.com/jedi4ever/veewee">an awesome project called Veewee</a> to build your own.
Again, building your box file is outside the scope of this article, so just
make sure you download a box with an OS that&rsquo;s to your liking.  This box DOES
NOT need to have Puppet preinstalled &ndash; in fact, it&rsquo;s probably better that it
doesn&rsquo;t (because the version will probably be old, and we&rsquo;re going to work
around this anyways). I&rsquo;m going to choose a CentOS 6.3 box that the SE team at
Puppet Labs uses for demos, but, again, it&rsquo;s up to you.</p>

<h2>Vagrantfile, assemble!</h2>

<p>Now that we&rsquo;ve got the pieces we need, let&rsquo;s start stitching together
a repeatable workflow. To do that, we&rsquo;ll need to create a directory for this
project and a <code>Vagrantfile</code> to direct Vagrant on how it should setup your VM.
I&rsquo;m going to use <code>~/src/vagrant_projects</code> for the purpose of this demo:</p>

<p>{% codeblock lang:bash %}
$ mkdir -p ~/src/vagrant_projects
$ cd ~/src/vagrant_projects
$ vim Vagrantfile
{% endcodeblock %}</p>

<p>Let&rsquo;s take a look at a sample Vagrantfile that I use to get Puppet installed on
a box:</p>

<p>{% codeblock lang:ruby Vagrantfile %}
Vagrant::Config.run do |config|
  config.vm.box       = &ldquo;centos-6.3-x86_64&rdquo;
  config.vm.box_url   = &ldquo;<a href="https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box">https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box</a>&rdquo;
  config.vm.host_name = &ldquo;development.puppetlabs.vm&rdquo;
  config.vm.network :hostonly, &ldquo;192.168.33.10&rdquo;
  config.vm.forward_port 80, 8084
  config.vm.provision :shell, :path => &ldquo;centos_6_x.sh&rdquo;
end
{% endcodeblock %}</p>

<p>Stepping through this file line-by-line, the first two <code>config.vm</code> lines
establish the box we want to use for our development VM as well as the URL to
the box file where it can be downloaded (in the event that it does not exist on
our system). Because, initially, this box will NOT be known to Vagrant, it will
attempt to reach out to that address and download it (note that the URL to THIS
PARTICULAR BOX is subject to change &ndash; please find a box file that works for you
and substitute its URL in the <code>config.vm.box_url</code> config setting).  The next
three lines define the machine&rsquo;s hostname, the network type, and the IP address
for this VM. In this case, I&rsquo;m using a host-only network and giving it an IP
address on a made-up 192.168.33.0/24 subnet (feel free to use your own
private IP range as long as it doesn&rsquo;t conflict with anything). The next line
is forwarding port 80 on the VM to port 8084 on my local laptop &ndash; this allows
you to test out web services by simply navigating to <a href="http://localhost:8084">http://localhost:8084</a>
from your web browser.  I&rsquo;ll save explaining the last line for the next
section.</p>

<p><strong>NOTE</strong>: For more documentation on these settings, <a href="http://docs.vagrantup.com/v1/docs/vagrantfile.html">visit Vagrant&rsquo;s documentation site</a>
as it&rsquo;s quite good</p>

<h2>Getting Puppet on your VM</h2>

<p>The final line in the sample Vagrantfile runs what&rsquo;s called the &lsquo;Shell
Provisioner&rsquo; for Vagrant. Essentially, it runs a shell script on the VM once
it&rsquo;s been booted and configured. What does this shell script do?</p>

<p>{% codeblock centos_6_x.sh lang:bash <a href="https://github.com/hashicorp/puppet-bootstrap/blob/master/centos_6_x.sh">https://github.com/hashicorp/puppet-bootstrap/blob/master/centos_6_x.sh</a> %}</p>

<h1>!/usr/bin/env bash</h1>

<h1>This bootstraps Puppet on CentOS 6.x</h1>

<h1>It has been tested on CentOS 6.3 64bit</h1>

<p>set -e</p>

<p>REPO_URL=&ldquo;<a href="http://yum.puppetlabs.com/el/6/products/i386/puppetlabs-release-6-6.noarch.rpm">http://yum.puppetlabs.com/el/6/products/i386/puppetlabs-release-6-6.noarch.rpm</a>&rdquo;</p>

<p>if [ &ldquo;$EUID&rdquo; -ne &ldquo;0&rdquo; ]; then
  echo &ldquo;This script must be run as root.&rdquo; >&amp;2
  exit 1
fi</p>

<p>if which puppet > /dev/null 2>&1; then
  echo &ldquo;Puppet is already installed&rdquo;
  exit 0
fi</p>

<h1>Install puppet labs repo</h1>

<p>echo &ldquo;Configuring PuppetLabs repo&hellip;&rdquo;
repo_path=$(mktemp)
wget &mdash;output-document=${repo_path} ${REPO_URL} 2>/dev/null
rpm -i ${repo_path} >/dev/null</p>

<h1>Install Puppet&hellip;</h1>

<p>echo &ldquo;Installing puppet&rdquo;
yum install -y puppet > /dev/null</p>

<p>echo &ldquo;Puppet installed!&rdquo;
{% endcodeblock %}</p>

<p>As you can see, it sets up the Puppet Labs el6 repository containing the
current packages for Puppet/Facter/Hiera/PuppetDB/etc and installs the most
recent version of Puppet and Facter that are in the repository. This will
ensure that you have the most recent version of Puppet on your VM, and you
don&rsquo;t need to worry about creating a new box every time Puppet releases a new
version.</p>

<p>This code <a href="https://github.com/hashicorp/puppet-bootstrap/blob/master/centos_6_x.sh">came from Mitchell&rsquo;s puppet-bootstrap repo</a> where he
maintains a list of scripts that will bootstrap Puppet onto many of the common
operating systems out there. This code was current as of the initial posting
date of this blog, but make sure to check that repo for any updates.  If you&rsquo;re
maintaining your OWN provisioning script, consider filing pull requests against
Mitchell&rsquo;s repo so we can ALL benefit from good code and don&rsquo;t have to keep
creating &lsquo;another wheel&rsquo; just to provision Puppet on VMs!</p>

<h2>Spin up your VM</h2>

<p>Once you&rsquo;ve created a <code>Vagrantfile</code> in a directory, the next logical thing to
do is to test out Vagrant and fire up your VM. Let&rsquo;s first check the status of
the vm:</p>

<p>{% codeblock lang:bash %}
$ vagrant status</p>

<p>Current VM states:</p>

<p>default                  not created</p>

<p>The environment has not yet been created. Run <code>vagrant up</code> to
create the environment.
{% endcodeblock %}</p>

<p>As expected, this VM has yet to be created, so let&rsquo;s do that by doing a <code>vagrant up</code></p>

<p>{% codeblock %}
$ vagrant up</p>

<p>[default] Box centos-6.3-x86_64 was not found. Fetching box from specified
URL&hellip;
<a href="http://www.vagrantup.com">vagrant</a> Downloading with Vagrant::Downloaders::HTTP&hellip;
<a href="http://www.vagrantup.com">vagrant</a> Downloading box:
<a href="https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box">https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box</a>
<a href="http://www.vagrantup.com">vagrant</a> Extracting box&hellip;
<a href="http://www.vagrantup.com">vagrant</a> Verifying box&hellip;
<a href="http://www.vagrantup.com">vagrant</a> Cleaning up downloaded box&hellip;
[default] Importing base box &lsquo;centos-6.3-x86_64&rsquo;&hellip;
[default] The guest additions on this VM do not match the install version of
VirtualBox! This may cause things such as forwarded ports, shared
folders, and more to not work properly. If any of those things fail on
this machine, please update the guest additions and repackage the
box.</p>

<p>Guest Additions Version: 4.1.18
VirtualBox Version: 4.1.23
[default] Matching MAC address for NAT networking&hellip;
[default] Clearing any previously set forwarded ports&hellip;
[default] Forwarding ports&hellip;
[default] &mdash; 22 => 2222 (adapter 1)
[default] &mdash; 80 => 8084 (adapter 1)
[default] Creating shared folders metadata&hellip;
[default] Clearing any previously set network interfaces&hellip;
[default] Preparing network interfaces based on configuration&hellip;
[default] Booting VM&hellip;
[default] Waiting for VM to boot. This can take a few minutes.
[default] VM booted and ready for use!
[default] Configuring and enabling network interfaces&hellip;
[default] Setting host name&hellip;
[default] Mounting shared folders&hellip;
[default] &mdash; v-root: /vagrant
[default] Running provisioner: Vagrant::Provisioners::Shell&hellip;
Configuring PuppetLabs repo&hellip;
warning:
/tmp/tmp.FvW0K7FJWU: Header V4 RSA/SHA1 Signature, key ID 4bd6ec30: NOKEY
Installing puppet
warning:
rpmts_HdrFromFdno: Header V4 RSA/SHA1 Signature, key ID 4bd6ec30: NOKEY
Importing GPG key 0x4BD6EC30:
 Userid : Puppet Labs Release Key (Puppet Labs Release Key) <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x69;&#x6e;&#x66;&#111;&#64;&#x70;&#117;&#112;&#112;&#x65;&#116;&#108;&#97;&#98;&#x73;&#x2e;&#x63;&#x6f;&#x6d;">&#x69;&#110;&#102;&#x6f;&#x40;&#x70;&#x75;&#x70;&#112;&#101;&#x74;&#108;&#x61;&#98;&#115;&#46;&#x63;&#x6f;&#109;</a>
 Package: puppetlabs-release-6-6.noarch (installed)
 From   : /etc/pki/rpm-gpg/RPM-GPG-KEY-puppetlabs
Warning: RPMDB altered outside of yum.
Puppet installed!
{% endcodeblock %}</p>

<p>Vagrant first noticed that we did not have the CentOS box on our machine, so it
downloaded, extracted, and verified the box before importing it and creating
our custom VM. Next, it configured the VM&rsquo;s network settings according to our
Vagrantfile, and finally it provisioned the box using the script we passed in
the Vagrantfile.</p>

<p>We&rsquo;ve now got a VM running and Puppet is installed. Let&rsquo;s ssh to our VM
and check the Puppet Version:</p>

<p>{% codeblock lang:bash %}
$ vagrant ssh</p>

<p>Last login: Tue Jul 10 22:56:01 2012 from 10.0.2.2
[vagrant@development ~]$ puppet &mdash;version
3.0.2
[vagrant@development ~]$ hostname
development.puppetlabs.vm
[vagrant@development ~]$ exit
logout
Connection to 127.0.0.1 closed.</p>

<p>$ vagrant destroy -f
[default] Forcing shutdown of VM&hellip;
[default] Destroying VM and associated drives&hellip;
{% endcodeblock %}</p>

<p>Cool &ndash; so we demonstrated that we could ssh into the VM, check the Puppet
version, check the hostname to ensure that Vagrant had set it correctly, exit
out, and then we finally destroyed the VM with <code>vagrant destroy -f</code>.  The next
step is to actually configure Puppet to DO something with this VM&hellip;</p>

<h2>Using Puppet to setup your node</h2>

<p>The act of GETTING a clean VM is all well and good (and is probably magic
enough for most people out there), but the purpose of this post is to
demonstrate a workflow for testing out Puppet code changes. In the previous
step we showed how to get Puppet installed, but we&rsquo;ve yet to demonstrate how
to use Vagrant&rsquo;s built-in <a href="http://docs.vagrantup.com/v1/docs/provisioners/puppet.html">Puppet provisioner</a> to configure your VM. Let&rsquo;s use
the example of a developer wanting to spin up a LAMP stack. To manually
configure that would require installing a number of packages, editing a number
of config files, and then making sure services were installed (among other
things). We&rsquo;re going to use some of the Puppet modules from the <a href="http://forge.puppetlabs.com">Puppet
Forge</a> to tackle these tasks and make Vagrant automatically configure
our VM.</p>

<h2>Scaffolding Puppet</h2>

<p>We need a way to pass our Puppet code to the VM Vagrant creates. Fortunately,
Vagrant has a way to define <a href="http://docs.vagrantup.com/v1/docs/config/vm/share_folder.html">Shared Folders</a> that can be shared from your
workstation and mounted on your VM at a particular mount point. Let&rsquo;s modify
our Vagrantfile to account for this shared folder:</p>

<p>{% codeblock lang:ruby Vagrantfile %}
Vagrant::Config.run do |config|
  config.vm.box       = &ldquo;centos-6.3-x86_64&rdquo;
  config.vm.box_url   = &ldquo;<a href="https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box">https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box</a>&rdquo;
  config.vm.host_name = &ldquo;development.puppetlabs.vm&rdquo;
  config.vm.network :hostonly, &ldquo;192.168.33.10&rdquo;
  config.vm.forward_port 80, 8084
  config.vm.provision :shell, :path => &ldquo;centos_6_x.sh&rdquo;</p>

<p>  # Puppet Shared Folder
  config.vm.share_folder &ldquo;puppet_mount&rdquo;, &ldquo;/puppet&rdquo;, &ldquo;puppet&rdquo;
end
{% endcodeblock %}</p>

<p>The syntax for the <code>config.vm.share_folder</code> line is that the first argument is
a logical name for the shared folder mapping, the second argument is the path
IN THE VM where this folder will be mounted (so, a folder called &lsquo;puppet&rsquo; in
the root of the filesystem), and the last argument is the path to the folder ON
YOUR WORKSTATION that will be mounted in the VM (it can be a full or relative
path &ndash; which is what we&rsquo;ve done here). This folder hasn&rsquo;t been created yet, so
let&rsquo;s create it (and a couple of subfolders):</p>

<p>{% codeblock lang:bash %}
$ cd ~/src/vagrant_projects
$ mkdir -p puppet/{manifests,modules}
{% endcodeblock %}</p>

<p>This command will create the <code>puppet</code> directory in the same directory that
contains our Vagrantfile, and then two subdirectories, <code>manifests</code> and
<code>modules</code>, that will be used by the Puppet provisioner later. Now that we&rsquo;ve
told Vagrant to create our shared folder, and we&rsquo;ve created the folder
structure, let&rsquo;s bring up the VM with <code>vagrant up</code> again, ssh into the VM with
<code>vagrant ssh</code>, and then check to see that the folder has been mounted.</p>

<p>{% codeblock lang:bash %}
$ vagrant up</p>

<p><output suppressed - see above for example output></p>

<p>$ vagrant ssh</p>

<p>Last login: Tue Jul 10 22:56:01 2012 from 10.0.2.2
[vagrant@development ~]$ ls /puppet
manifests  modules
{% endcodeblock %}</p>

<p>Great! We&rsquo;ve setup a shared folder. To further test it out, you can try
dropping a file in the puppet directory or one of its subdirectories &ndash; it
should immediately show up on the VM without having to recreate the VM (because
it&rsquo;s a shared folder). There are pros and cons with this workflow &ndash; the main
pro is that changes you make on your workstation will immediately be reflected
in the VM, and the main con is that you can&rsquo;t symlink folders INSIDE
the shared folder on your workstation because of the nature of symlinks.</p>

<h2>Installing the necessary Puppet Modules</h2>

<p>Since we&rsquo;ve already spun up a new VM and ssh&rsquo;d into it, let&rsquo;s use our VM to
download modules we&rsquo;re going to need to setup our LAMP stack:</p>

<p>{% codeblock lang:bash %}
[vagrant@development ~]$ puppet module install puppetlabs/apache &mdash;target-dir /puppet/modules/
Notice: Preparing to install into /puppet/modules &hellip;
Notice: Downloading from <a href="https://forge.puppetlabs.com">https://forge.puppetlabs.com</a> &hellip;
Notice: Installing &mdash; do not interrupt &hellip;
/puppet/modules
└─┬ puppetlabs-apache (v0.5.0-rc1)
  ├── puppetlabs-firewall (v0.0.4)
  └── puppetlabs-stdlib (v3.2.0)</p>

<p>[vagrant@development ~]$ puppet module install puppetlabs/mysql &mdash;target-dir /puppet/modules/
Notice: Preparing to install into /puppet/modules &hellip;
Notice: Downloading from <a href="https://forge.puppetlabs.com">https://forge.puppetlabs.com</a> &hellip;
Notice: Installing &mdash; do not interrupt &hellip;
/puppet/modules
└── puppetlabs-mysql (v0.6.1)</p>

<p>[vagrant@development ~]$ ls /puppet/modules/
apache  concat  firewall  mysql  stdlib
{% endcodeblock %}</p>

<p>The <code>puppet</code> binary has a module subcommand that will connect to the <a href="http://forge.puppetlabs.com">Puppet Forge</a>
to download Puppet modules and their dependencies. The commands we used will
install Puppet Labs' <code>apache</code> and <code>mysql</code> modules (and their dependencies).
We&rsquo;re also passing the <code>--target-dir</code> argument that will tell the <code>puppet
module</code> subcommand to install the module into our shared directory (instead of
Puppet&rsquo;s default module path).</p>

<p>I&rsquo;m choosing to use <code>puppet module</code> to install these modules, but there are
a multitude of other methods you can use (from downloading the modules directly
out of <a href="http://github.com">Github</a> to using a tool like <a href="https://github.com/rodjek/librarian-puppet">librarian-puppet</a>). The point is
that we need to ultimately get the modules into the <code>modules</code> directory
in our shared <code>puppet</code> folder &ndash; however you want to do that works for me :)</p>

<p>Once the modules are in <code>puppet/modules</code>, we&rsquo;re good. You only ever need to do
this step ONCE. Because this folder is a shared folder, you can now <code>vagrant
up</code> and <code>vagrant destroy</code> to your heart&rsquo;s content &ndash; Vagrant will not remove the
content in our shared folder when a VM is destroyed. Remember, too, that any
changes made to those modules from either the VM or on your Workstation will be
IMMEDIATELY available to both.</p>

<p>Since we&rsquo;re now done with the VM for now, let&rsquo;s destroy it with <code>vagrant destroy</code></p>

<p>{% codeblock %}
$ vagrant destroy
{% endcodeblock %}</p>

<h2>Classifying your development VM</h2>

<p>The modules we installed are a framework that we will use to configure the
node. The act of directing the actions that Puppet should take on a particular
node is called <a href="http://docs.puppetlabs.com/puppet/3/reference/lang_summary.html#resources-classes-and-nodes">&lsquo;Classification&rsquo;</a>. Puppet uses a file called <a href="http://docs.puppetlabs.com/learning/agent_master_basic.html#sitepp">site.pp</a>
to map Puppet code with the corresponding &lsquo;node&rsquo; (or, in our case, our VM) that
should receive it. Let&rsquo;s create a site.pp file and open it for editing:</p>

<p>{% codeblock %}
$ cd ~/src/vagrant_projects
$ vim puppet/manifests/site.pp
{% endcodeblock %}</p>

<p>Let&rsquo;s create a site.pp that will setup the LAMP stack on our
<code>development.puppetlabs.vm</code> that we create with Vagrant:</p>

<p>{% codeblock lang:puppet ~/src/vagrant_projects/manifests/site.pp %}
node &lsquo;development.puppetlabs.vm&rsquo; {
  # Configure mysql
  class { &lsquo;mysql::server&rsquo;:</p>

<pre><code>config_hash =&gt; { 'root_password' =&gt; '8ZcJZFHsvo7fINZcAvi0' }
</code></pre>

<p>  }
  include mysql::php</p>

<p>  # Configure apache
  include apache
  include apache::mod::php
  apache::vhost { $::fqdn:</p>

<pre><code>port    =&gt; '80',
docroot =&gt; '/var/www/test',
require =&gt; File['/var/www/test'],
</code></pre>

<p>  }</p>

<p>  # Configure Docroot and index.html
  file { [&lsquo;/var/www&rsquo;, &lsquo;/var/www/test&rsquo;]:</p>

<pre><code>ensure =&gt; directory
</code></pre>

<p>  }</p>

<p>  file { &lsquo;/var/www/test/index.php&rsquo;:</p>

<pre><code>ensure  =&gt; file,
content =&gt; '&lt;?php echo \'&lt;p&gt;Hello World&lt;/p&gt;\'; ?&gt; ',
</code></pre>

<p>  }</p>

<p>  # Realize the Firewall Rule
  Firewall &lt;||>
}
{% endcodeblock %}</p>

<p>Again, the point of this post is not about writing Puppet code but more about
testing the Puppet code you write. The above node declaration will setup MySQL
with a root password of &lsquo;puppet&rsquo;, setup Apache and a VHost for
<code>development.puppetlabs.vm</code> with a docroot out of <code>/var/www/test</code>, setup an
<code>index.php</code> file for Apache, and setup a Firewall rule to allow access through
to port 80 on our VM.</p>

<h2>Setting up the Puppet provisioner for Vagrant</h2>

<p>We&rsquo;re going to have to modify our <code>Vagrantfile</code> one more time to tell Vagrant
to use the <a href="http://docs.vagrantup.com/v1/docs/provisioners/puppet.html">Puppet provisioner</a> to execute our Puppet code and setup our VM:</p>

<p>{% codeblock lang:ruby Vagrantfile%}
Vagrant::Config.run do |config|
  config.vm.box       = &ldquo;centos-6.3-x86_64&rdquo;
  config.vm.box_url   = &ldquo;<a href="https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box">https://saleseng.s3.amazonaws.com/boxfiles/CentOS-6.3-x86_64-minimal.box</a>&rdquo;
  config.vm.host_name = &ldquo;development.puppetlabs.vm&rdquo;
  config.vm.network :hostonly, &ldquo;192.168.33.10&rdquo;
  config.vm.forward_port 80, 8084
  config.vm.provision :shell, :path => &ldquo;centos_6_x.sh&rdquo;</p>

<p>  # Puppet Shared Folder
  config.vm.share_folder &ldquo;puppet_mount&rdquo;, &ldquo;/puppet&rdquo;, &ldquo;puppet&rdquo;</p>

<p>  # Puppet Provisioner setup
  config.vm.provision :puppet do |puppet|</p>

<pre><code>puppet.manifests_path = "puppet/manifests"
puppet.module_path    = "puppet/modules"
puppet.manifest_file  = "site.pp"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>Notice the block for the Puppet provisioner that sets up the manifest path (i.e. where
to find <code>site.pp</code>), the module path (i.e. where to find our Puppet modules),
and the name of our manifest file (i.e. <code>site.pp</code>). Again, <a href="http://docs.vagrantup.com/v1/docs/provisioners/puppet.html">this is all documented</a>
on the <a href="http://www.vagrantup.com">Vagrant</a> documentation page should you need to use it for
reference.</p>

<p>This bumps the number of provisioners in our <code>Vagrantfile</code> to two, but which
one goes first? Vagrant will iterate through the <code>Vagrantfile</code> procedurally, so
the Shell provisioner will always get checked first and then the Puppet
provisioner will get checked second.  This allows us to be certain that Puppet
will always be installed before attempting to use the Puppet provisioner. You
could continue to add as many provisioning blocks as you like &ndash; Vagrant will
iterate through them procedurally as it encounters them.</p>

<h2>Give the entire workflow a try</h2>

<p>Now that we have our Vagrantfile finalized, our Puppet directory structure
setup, our Puppet modules installed, and our <code>site.pp</code> file set to classify our
new VM, let&rsquo;s actually let Vagrant do what it does best and setup our VM:</p>

<p>{% codeblock %}
$ vagrant up
{% endcodeblock %}</p>

<p>You should see Vagrant use the Shell provisioner to install Puppet, hand off to
the Puppet provisioner, and then use Puppet to setup a LAMP stack on our VM.
After everything completes, try visiting <a href="http://localhost:8084">http://localhost:8084</a>
in your web browser and see if you get a shiny &ldquo;Hello World&rdquo; staring back at
you.  If you do &ndash; Awesome!  If you don&rsquo;t, check the error messages to determine
if there are typos in the Puppet code or if something went wrong in the <code>Vagrantfile</code>.</p>

<h2>Where do you take it from here?</h2>

<p>The first thing to do is to take the Vagrantfile you&rsquo;ve created and put it
under revision control so you can track the changes you make. I personally have
a couple of workflows up on <a href="http://github.com">Github</a> that I use as templates when I&rsquo;m
testing out something new. You&rsquo;ll probably find that your Vagrantfile won&rsquo;t
change much &ndash; just the modules you use for testing.</p>

<p>Now that you understand the pattern, you can expand it to fit your workflow.
Single-vm projects are great when you&rsquo;re testing a specific component, but
the next logical step is to test out multi-tiered components/applications.  In these instances,
<a href="http://docs.vagrantup.com/v1/docs/multivm.html">Vagrant has the ability to spin up multiple VMs from a single Vagrantfile</a>.
That workflow saves a TON of time and lets you create your own private network
of VMs for the purpose of simulating changes.  That&rsquo;s a post for another time,
though&hellip;</p>

<h2>Get involved</h2>

<p>Stay tuned to the <a href="http://www.vagrantup.com">Vagrant website</a> for updates on the VMware
provisioner.  Stability with Virtualbox has notoriously been an issue, but, as
of this posting, things have been relatively rock-solid for me (using
Virtualbox version 4.1.23 on OS X).</p>

<p>If you want to keep up-to-date on all things Vagrant, follow <a href="http://twitter.com/mitchellh">Mitchell</a> on
Twitter, check out <code>#vagrant</code> on Freenode, join <a href="http://groups.google.com/group/vagrant-up">the Vagrant list</a>, and
check out Google for what other folks have done!</p>

<p>A GIANT thank you to <a href="http://twitter.com/mitchellh">Mitchell Hashimoto</a> for all the work he&rsquo;s done on
Vagrant &ndash; I can&rsquo;t count the number of hours it&rsquo;s saved me personally (let ALONE
everyone at <a href="http://www.puppetlabs.com">Puppet Labs</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Run Stages with Puppet]]></title>
    <link href="http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/"/>
    <updated>2011-03-11T11:34:00-08:00</updated>
    <id>http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet</id>
    <content type="html"><![CDATA[<p>As of version 2.6, Puppet introduced a feature called &ldquo;Run Stages&rdquo; that will allow you to better control the order that Puppet configures your system.  The problem with Run Stages (as of right now) is that there&rsquo;s not that much good Documentation out there.  Hopefully this document helps someone else out there who wants to setup Run Stages in their own environment.</p>

<h2>A NOTE ON SYNTAX!!!</h2>

<p>One of THE MOST DIFFICULT concepts to understand for puppet newbies is that these two things are identical:</p>

<p>```puppet</p>

<pre><code>include foo
class { 'foo': }
</code></pre>

<p>```</p>

<p>Both of these lines INVOKE the &lsquo;foo&rsquo; class for use on a particular node.  The problem is that the second method (the parameterized class method) looks nearly IDENTICAL to the method you would use to DECLARE the foo class in foo.pp.  The only difference is that the class name is now INSIDE the curly braces (versus being OUTSIDE the braces when you DECLARE the class in your foo.pp file).  It is VERY important that you distinguish the difference between DECLARING a class and using a parameterized class to INCLUDE the class in your site.pp file.  I will point this out later too&hellip;</p>

<h2>A Linux Example &ndash; Repositories</h2>

<p>I would bet that the resource with the most &ldquo;require&rdquo; and &ldquo;before&rdquo; dependencies in the Linux world (Well, in the RHEL world anyways) would be the yumrepo.  I&rsquo;m sure most of us have many declared yumrepo resources in our manifests that each have their own tangled web of dependencies.  My goal was to create a &ldquo;repo&rdquo; class that would have all of my repositories and use a Run Stage to ensure that my repo class was installed prior to any other package installs.  Let&rsquo;s look at some code:</p>

<p>```puppet
class general::repo {
  yumrepo { &lsquo;huronrepo&rsquo;:</p>

<pre><code>descr    =&gt; 'Huron Repository',
enabled  =&gt;  '1',
gpgcheck =&gt;  '0',
baseurl  =&gt;  'http://10.13.0.6/huronrepo',
</code></pre>

<p>  }
}
```</p>

<p>This is my repo subclass based on my general base class.  I have a single repository, but could easily have another 5 or 10 as need arises (I&rsquo;m keeping things simple for demo purposes).  Let&rsquo;s look at another class:</p>

<p>```puppet
class general::centos {
  include general::repo</p>

<p>  package { &lsquo;mcollective&rsquo;:</p>

<pre><code>name    =&gt; "mcollective",
ensure  =&gt; 'present',
require =&gt; Package['stomp'],
</code></pre>

<p>  }
}
```</p>

<p>Here&rsquo;s a centos subclass off of the general base class.  We&rsquo;re including our repo class and declaring a single package that requires our &ldquo;huronrepo&rdquo; yumrepo.  If we only needed to install a single package, we could use the &ldquo;require&rdquo; parameter; but if you assume that we will eventually need to install MULTIPLE packages, then this logic doesn&rsquo;t scale. Just to keep things consistent, here&rsquo;s my general base class:</p>

<p>```puppet
class general {
  case $::operatingsystem {</p>

<pre><code>'CentOS': { include general::centos }
'Darwin': { include general::osx }
</code></pre>

<p>  }
}
```</p>

<p>You can see that we include the general::centos class as long as Puppet is running on a CentOS box.  There&rsquo;s one final piece to this puzzle &ndash; it&rsquo;s the actual declaration and assignment of the Run Stages.  I&rsquo;m doing this in my site.pp file.  Here&rsquo;s a snippit of what&rsquo;s in my site.pp file:</p>

<p>```puppet</p>

<h1>/etc/puppet/manifests/site.pp</h1>

<p>Exec { path =&gt; &ldquo;/usr/bin:/usr/sbin:/bin:/sbin&rdquo; }</p>

<h1>Run Stages</h1>

<p>stage { &lsquo;pre&rsquo;:
  before => Stage[&ldquo;main&rdquo;],
}</p>

<h1>Node Declaration</h1>

<p>node &lsquo;server.whomever.com&rsquo; {
  class { &lsquo;general::repos&rsquo;:</p>

<pre><code>stage =&gt; 'pre'
</code></pre>

<p>  }
}
```</p>

<p>Here&rsquo;s where we&rsquo;ve declared a &ldquo;pre&rdquo; stage that needs to run before the &ldquo;main&rdquo; stage.  We don&rsquo;t have to declare the &ldquo;main&rdquo; stage because Puppet uses that stage by default.  Next, we&rsquo;re including the general::repos class inside our &lsquo;server.whomever.com&rsquo; node declaration and assigning it to the &ldquo;pre&rdquo; stage (which means that everything in that class will get configured prior to our &ldquo;main&rdquo; stage).  Remember that you can declare as many stages as you need and chain them all to setup the order that you want, but that can become very unmanageable very quickly.  I find it ideal to setup a &lsquo;pre&rsquo; stage for repo setup, and then setting up dependencies within class files.</p>

<h2>The World is Your Stage</h2>

<p>This might not be the &ldquo;best&rdquo; way to use Run Stages, but it works for me.  Hopefully this little writeup cements the concept for you too.</p>
]]></content>
  </entry>
  
</feed>
